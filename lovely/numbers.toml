[manifest]
version = "1.0.0"
dump_lua = true
priority = 0


#fixing engine
[[patches]]
[patches.regex]
target = "engine/controller.lua"
pattern = "((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+) (>|<|>=|<=|==) ((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+)"
position = "at"
payload = "(Number and Number:new($1) or ($1)) $2 (Number and Number:new($3) or ($3))"
[[patches]]
[patches.regex]
target = "engine/moveable.lua"
pattern = "((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+) (>|<|>=|<=|==) ((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+)"
position = "at"
payload = "(Number and Number:new($1) or ($1)) $2 (Number and Number:new($3) or ($3))"
[[patches]]
[patches.regex]
target = "engine/sound_manager.lua"
pattern = "((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+) (>|<|>=|<=|==) ((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+)"
position = "at"
payload = "(Number and Number:new($1) or ($1)) $2 (Number and Number:new($3) or ($3))"
[[patches]]
[patches.regex]
target = "engine/text.lua"
pattern = "((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+) (>|<|>=|<=|==) ((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+)"
position = "at"
payload = "(Number and Number:new($1) or ($1)) $2 (Number and Number:new($3) or ($3))"
[[patches]]
[patches.regex]
target = "engine/ui.lua"
pattern = "((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+) (>|<|>=|<=|==) ((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+)"
position = "at"
payload = "(Number and Number:new($1) or ($1)) $2 (Number and Number:new($3) or ($3))"

#fixing functions
[[patches]]
[patches.regex]
target = "functions/button_callbacks.lua"
pattern = "((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+) (>|<|>=|<=|==) ((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+)"
position = "at"
payload = "(Number and Number:new($1) or ($1)) $2 (Number and Number:new($3) or ($3))"
# [[patches]]
# [patches.regex]
# target = "functions/common_events.lua"
# pattern = "<= math\\.max\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)"
# position = "at"
# payload = "<= (Number and Number:new(math.max($1)) or (math.max($1)))"
[[patches]]
[patches.regex]
target = "functions/common_events.lua"
pattern = "((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+) (>|<|>=|<=|==) ((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+)"
position = "at"
payload = "(Number and Number:new($1) or ($1)) $2 (Number and Number:new($3) or ($3))"
[[patches]]
[patches.regex]
target = "functions/misc_functions.lua"
pattern = "((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+) (>|<|>=|<=|==) ((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+)"
position = "at"
payload = "(Number and Number:new($1) or ($1)) $2 (Number and Number:new($3) or ($3))"
[[patches]]
[patches.regex]
target = "functions/state_events.lua"
pattern = "((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+) (>|<|>=|<=|==) ((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+)"
position = "at"
payload = "(Number and Number:new($1) or ($1)) $2 (Number and Number:new($3) or ($3))"
[[patches]]
[patches.regex]
target = "functions/UI_definitions.lua"
pattern = "((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+) (>|<|>=|<=|==) ((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+)"
position = "at"
payload = "(Number and Number:new($1) or ($1)) $2 (Number and Number:new($3) or ($3))"

#fixing rest
[[patches]]
[patches.regex]
target = "back.lua"
pattern = "((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+) (>|<|>=|<=|==) ((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+)"
position = "at"
payload = "(Number and Number:new($1) or ($1)) $2 (Number and Number:new($3) or ($3))"
[[patches]]
[patches.regex]
target = "blind.lua"
pattern = "((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+) (>|<|>=|<=|==) ((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+)"
position = "at"
payload = "(Number and Number:new($1) or ($1)) $2 (Number and Number:new($3) or ($3))"
[[patches]]
[patches.regex]
target = "card.lua"
pattern = "((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+) (>|<|>=|<=|==) ((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+)"
position = "at"
payload = "(Number and Number:new($1) or ($1)) $2 (Number and Number:new($3) or ($3))"
[[patches]]
[patches.regex]
target = "cardarea.lua"
pattern = "((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+) (>|<|>=|<=|==) ((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+)"
position = "at"
payload = "(Number and Number:new($1) or ($1)) $2 (Number and Number:new($3) or ($3))"
[[patches]]
[patches.regex]
target = "game.lua"
pattern = "((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+) (>|<|>=|<=|==) ((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+)"
position = "at"
payload = "(Number and Number:new($1) or ($1)) $2 (Number and Number:new($3) or ($3))"
[[patches]]
[patches.regex]
target = "main.lua"
pattern = "((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+) (>|<|>=|<=|==) ((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+)"
position = "at"
payload = "(Number and Number:new($1) or ($1)) $2 (Number and Number:new($3) or ($3))"
[[patches]]
[patches.regex]
target = "tag.lua"
pattern = "((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+) (>|<|>=|<=|==) ((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+)"
position = "at"
payload = "(Number and Number:new($1) or ($1)) $2 (Number and Number:new($3) or ($3))"

# adding for annotations

# top level
[[patches]]
[patches.pattern]
target = "card_character.lua"
pattern = "ϖ"
position = "at"
payload = "ϖ"
match_indent = true
times = 1
[[patches]]
[patches.pattern]
target = "challenges.lua"
pattern = "ϖ"
position = "at"
payload = "ϖ"
match_indent = true
times = 1
[[patches]]
[patches.pattern]
target = "challenges.lua"
pattern = "ϖ"
position = "at"
payload = "ϖ"
match_indent = true
times = 1
[[patches]]
[patches.pattern]
target = "conf.lua"
pattern = "ϖ"
position = "at"
payload = "ϖ"
match_indent = true
times = 1

# engine
[[patches]]
[patches.pattern]
target = "engine/event.lua"
pattern = "ϖ"
position = "at"
payload = "ϖ"
match_indent = true
times = 1
[[patches]]
[patches.pattern]
target = "engine/http_manager.lua"
pattern = "ϖ"
position = "at"
payload = "ϖ"
match_indent = true
times = 1
[[patches]]
[patches.pattern]
target = "engine/node.lua"
pattern = "ϖ"
position = "at"
payload = "ϖ"
match_indent = true
times = 1
[[patches]]
[patches.pattern]
target = "engine/object.lua"
pattern = "ϖ"
position = "at"
payload = "ϖ"
match_indent = true
times = 1
[[patches]]
[patches.pattern]
target = "engine/particles.lua"
pattern = "ϖ"
position = "at"
payload = "ϖ"
match_indent = true
times = 1
[[patches]]
[patches.pattern]
target = "engine/profile.lua"
pattern = "ϖ"
position = "at"
payload = "ϖ"
match_indent = true
times = 1
[[patches]]
[patches.pattern]
target = "engine/string_packer.lua"
pattern = "ϖ"
position = "at"
payload = "ϖ"
match_indent = true
times = 1

# functions
[[patches]]
[patches.pattern]
target = "functions/test_functions.lua"
pattern = "ϖ"
position = "at"
payload = "ϖ"
match_indent = true
times = 1



# other
# moveable
[[patches]]
[patches.pattern]
target = "engine/moveable.lua"
pattern = "---@class Moveable: Node"
position = "at"
payload = '''

---@class RoleObject
---@field offset Position2D
---@field role_type ('Major'|'Minor'|'Glued')?
---@field bond ('Strong'|'Weak')?
---@field xy_bond ('Strong'|'Weak')?
---@field wh_bond ('Strong'|'Weak')?
---@field r_bond ('Strong'|'Weak')?
---@field scale_bond ('Strong'|'Weak')?
---@field type ('tl'|'tm'|'tr'|'cl'|'cm'|'cr'|'bl'|'bm'|'br'|'tli'|'tmi'|'tri'|'cli'|'cmi'|'cri'|'bli'|'bmi'|'bri'|string)?
---@field draw_major Moveable?
---@field major Moveable?

---@class Moveable: Node
---@field role RoleObject
---@field zoom number?
---@operator call:Moveable'''
match_indent = true
times = 1
[[patches]]
[patches.pattern]
target = "engine/moveable.lua"
pattern = "---@param args {T: table, container: Node}"
position = "at"
payload = '''

---@function
---@param X ({T:[number,number,number,number]}|number)?
---@param Y number?
---@param W number?
---@param H number?'''
match_indent = true
times = 1
[[patches]]
[patches.pattern]
target = "engine/moveable.lua"
pattern = "---@param args {major: Moveable, bond: string, offset: table, type: string}"
position = "at"
payload = "---@param args (RoleObject|Moveable)?"
match_indent = true
times = 1

#UI
[[patches]]
[patches.pattern]
target = "engine/ui.lua"
pattern = "--Class"
position = "at"
payload = '''

---@class UIBox: Moveable
---@operator call:UIBox'''
match_indent = true
times = 1
[[patches]]
[patches.pattern]
target = "engine/ui.lua"
pattern = "---@param args {T: table, definition: table, config: table}"
position = "at"
payload = "---@param args UIBox|Moveable"
match_indent = true
times = 1
[[patches]]
[patches.pattern]
target = "engine/ui.lua"
pattern = "--Class"
position = "at"
payload = '''

---@alias UITransform {Root:any,T:any,O:any,B:any,C:any,R:any}
---@class UIElement: Moveable
---@field parent UIElement
---@operator call:UIElement'''
match_indent = true
times = 1
[[patches]]
[patches.pattern]
target = "engine/ui.lua"
pattern = "--Class Methods"
position = "at"
payload = '''

---@function
---@param parent (UIElement|UIBox)
---@param new_UIBox UIBox
---@param new_UIT UITransform
---@param config table'''
match_indent = true
times = 1

#node
[[patches]]
[patches.pattern]
target = "engine/node.lua"
pattern = "---@class Node"
position = "at"
payload = '''

---@alias Transform2D {x:number|0,y:number|0,w:number|1,h:number|1,r:number|0,scale:number|1}
---@alias ChildNodes {d_popup: UIBox,h_popup: UIBox, alert: UIBox,rest...:Node}

---@class Node: Object
---@field T Transform2D
---@field CT Transform2D
---@field VT Transform2D?
---@field DEBUG_VALUE string?
---@field CALCING boolean?
---@field children ChildNodes
---@operator call:Node'''
match_indent = true
times = 1
[[patches]]
[patches.pattern]
target = "engine/node.lua"
pattern = "---@param args {T: table, container: Node}"
position = "at"
payload = '''---@param args {T: [number?,number?,number?,number?,number?,number?]|{x:number?,y:number?,w:number?,h:number?,r:number?,scale:number?}, container: Node}'''
match_indent = true
times = 1

#controller
[[patches]]
[patches.pattern]
target = "engine/controller.lua"
pattern = "---@class Controller"
position = "at"
payload = '''

---@alias Position2D {x:number,y:number}

---@class ControlHandle
---@field handled boolean
---@field target (Card|Node|UIElement)?
---@field time number?
---@field prev_target (Card|Node|UIElement)?
---@field T Position2D?

---@class Controller: Object
---@field clicked ControlHandle
---@field focused ControlHandle
---@field dragging ControlHandle
---@field hovering ControlHandle
---@field released_on ControlHandle
---@field cursor_down ControlHandle
---@field cursor_up ControlHandle
---@field cursor_hover ControlHandle
---@operator call:Controller'''
match_indent = true
times = 1

#object
[[patches]]
[patches.pattern]
target = "engine/object.lua"
pattern = "Object = {}"
position = "at"
payload = '''

---@class Object
---@operator call:Object
Object = {}'''
match_indent = true
times = 1

#event
[[patches]]
[patches.pattern]
target = "engine/event.lua"
pattern = "--Class"
position = "at"
payload = '''

---@class Event:Object
---@operator call:Event'''
match_indent = true
times = 1
[[patches]]
[patches.pattern]
target = "engine/event.lua"
pattern = "--Class Methods"
position = "at"
payload = '''

---@class EventConfig
---@field blockable boolean?
---@field blocking boolean?
---@field trigger ('immediate'|'ease'|'condition'|'after'|'before')?
---@field start_timer boolean?
---@field no_delete boolean?
---@field delay number?
---@field timer ('BACKGROUND'|'REAL'|'REAL_SHADER'|'TOTAL'|'UPTIME')?
---@field ease ('lerp'|'elastic'|'quad')?
---@field ease_to number?
---@field func (fun(progress: number): boolean)?
---@field ref_table table?
---@field ref_value string?
---@field stop_val any?
---@field pause_force boolean?

---@function
---@param config EventConfig'''
match_indent = true
times = 1
[[patches]]
[patches.pattern]
target = "engine/event.lua"
pattern = "--Class"
position = "at"
payload = '''

---@class EventManager:Object
---@operator call:EventManager'''
match_indent = true
times = 1


#Big object patch
[[patches]]
[patches.pattern]
target = "engine/object.lua"
pattern = "Object = {}"
position = "at"
payload = '''Object = {}

---Removes the leading and trailing whitespace characters from a string.
---@param self string
---@return string
function string.trim(self)
    return self:match("^%s*(.-)%s*$")
end

---Converts <code>object</code> into a number using javascript rules (nil is undefined).<br>
---Returns <code>NaN</code> if <code>object</code> could not be converted into a number.
---@param object any
---@return number|Number|nil
_G.numer = function(object)
    if type(object) == "number" then return object end
    if type(object) == "boolean" then return object and 1 or 0 end
    if type(object) == "string" then
        if object == "Infinity" then return Infinity end
        if object == "-Infinity" then return -Infinity end
        if object == "" then return 0 end
    end
    return tonumber(object) or NaN
end

---comment
---@param v any
---@param ... any
---@return Card
_G.safetypecard = function(v,...)
    assert(getmetatable(v)==Card,...)
    return v
end

---comment
---@param str any
---@param ... any
---@return string
_G.safestr = function(str,...)
    assert(type(str) == "string",...)
    return str
end


---comment
---@param tbl any
---@param ... any
---@return table
_G.safetable = function(tbl,...)
    assert(type(tbl) == "table",...)
    return tbl
end

---comment
---@param bl any
---@param ... any
---@return boolean
_G.safebool = function(bl,...)
    assert(type(bl) == "boolean",...)
    return bl
end


_G.dump = function(o)
    if type(o) == 'table' then
        local s = '{ '
        for k,v in pairs(o) do
            if type(k) ~= 'number' then k = '"'..k..'"' end
            s = s .. '['..k..'] = ' .. dump(v) .. ','
        end
        return s .. '} '
    else
        return tostring(o)
    end
end

_G.copy = function(obj, seen)
    if type(obj) ~= 'table' then return obj end
    if seen and seen[obj] then return seen[obj] end
    local s = seen or {}
    local res = setmetatable({}, getmetatable(obj))
    s[obj] = res
    for k, v in pairs(obj) do res[copy(k, s)] = copy(v, s) end
    return res
end

_G.solvepredicate = function(pred)
    if pred == nil then
        pred = function() return true end
    end
    if type(pred) == "boolean" then
        if pred then
            pred = function(v)
                return bool(v)
            end
        else
            pred = function(v)
                return not bool(v)
            end
        end
    end
    if type(pred) == "table" then
        local comparisonType = pred.match or "and"
        if comparisonType == "and" then
            local predicates = pred
            pred = function(...)
                for i,cond in ipairs(predicates) do
                    if not bool(solvepredicate(cond)(...)) then
                        return false
                    end
                end
                return true
            end
        elseif comparisonType == "or" then
            local predicates = pred
            pred = function(...)
                for i,cond in ipairs(predicates) do
                    if bool(solvepredicate(cond)(...)) then
                        return true
                    end
                end
                return false
            end
        end
    end
    if type(pred) ~= "function" then
        local val = pred
        pred = function(v)
            return v == val
        end
    end
    return pred
end

---Returns true if some value inside the list matched the predicate.
---@param tbl table
---@param pred any
---@return boolean
function table.some(tbl,pred)
    pred = solvepredicate(pred)
    for i,v in ipairs(tbl) do
        if pred(v,i,tbl) then
            return true
        end
    end
    return false
end

---Returns true if every value inside the list matched the predicate.
---@param tbl any
---@param pred any
---@return boolean
function table.every(tbl,pred)
   pred = solvepredicate(pred)
   for i,v in ipairs(tbl) do
       if not pred(v,i,tbl) then
           return false
       end
   end
   return true
end

function table.implement(tbl,impl)
    for k,v in pairs(impl) do
        if k == "@override" then goto continue end
        if tbl[k] == nil then
            tbl[k] = v
        elseif type(v) == "table" and type(tbl[k]) == "table" then
            table.implement(tbl[k],v)
        end
        ::continue::
    end
    for k,v in pairs(impl["@override"] or {}) do
        if type(tbl[k]) == "table" and type(v) == "table" then
            table.implement(tbl[k],{["@override"] = v})
        elseif type(tbl[k]) == "function" and v == nil then
            goto continue
        elseif (type(tbl[k]) == "function" or tbl[k] == nil) and type(v) == "function" then
            tbl[k] = v(tbl[k] or function() end)
        else
            tbl[k] = v
        end
        ::continue::
    end
end

function table.get(tbl,...)
    local got = nil
    for i,v in ipairs({...}) do
         if got == nil then
            got = tbl
         end
         got = got[v]
         if got == nil then
            return got
         end
    end
    return got
end

function table.set(tbl,...)
    if type(tbl) ~= "table" then return error("table expected!") end
    local setter = tbl
    local parent = nil
    local args = {...}
    for i,v in ipairs(args) do
        if i == #args then break end
        if setter == nil then 
          parent[v] = {}
          setter = parent[v]
        end
        parent = setter
        setter = setter[v]
    end
    parent[args[#args-1]] = args[#args]
end

function table.at(tbl,index)
    if index == 0 then return nil end
    if index > #tbl then return nil end
    if index < -#tbl then return nil end
    if #tbl == 0 then return nil end
    if #tbl == 1 then return tbl[1] end
    index = index%#tbl
    if index == 0 then index = #tbl end
    return tbl[index]
end

function table.slice(tbl,first,last,step)
    local sliced = {}
    local slice_start = 1
    local slice_end = #tbl
    local slice_step = 1
    local last_is_negative = last and last < 0 or false
    if last_is_negative then
        slice_end = #tbl+last
    elseif last then
        slice_end = last
    end
    local first_is_negative = first and first < 0 or false
    if first_is_negative then
        slice_start = #tbl+first+1
    elseif first then
        slice_start = first
    end
    if slice_start == slice_end then
      sliced[1] = tbl[slice_start]
      return sliced
    end
    local step_is_negative = step and step < 0 or false
    if step_is_negative then
        slice_step = -step
        first_index,last_index = last_index,first_index
    elseif step then
        slice_step = step
    end
    for i=slice_start,slice_end, slice_step do
        sliced[#sliced+1] = tbl[i]
    end
    return sliced
end

---Returns the amount of entries in the list that matched the filter.
---@param tbl table
---@param pred any
---@return integer
function table.count(tbl,pred)
    pred = solvepredicate(pred)
    local count = 0
    for i,v in ipairs(tbl) do
        if pred(v,i,tbl) then
            count = count + 1
        end
    end
    return count
end

---Returns a new list with all the entries of the list that passed the filter.
---@generic H: table
---@param tbl `H`
---@param pred any
---@return H
function table.filter(tbl,pred)
    local rv = {}
    pred = solvepredicate(pred)
    for i,v in ipairs(tbl) do
        if pred(v,i,tbl) then
            table.insert(rv,v)
        end
    end
    return rv
end

---Returns the sum of all the values inside the list.
---@param tbl table
---@param pred any
---@return number
function table.sum(tbl,pred)
    local sum = 0
    pred = solvepredicate(pred)
    for i,v in ipairs(tbl) do
        if pred(v,i,tbl) then
            sum = sum + numer(v)
        end
    end
    return sum
end

---Returns a new list with each value mapped with the mapping function.
---@generic H: table
---@param tbl `H`
---@generic T
---@param func fun(value: any,index: integer,table: H): `T`
---@param pred any
---@return T[]
function table.map(tbl,func,pred)
    local rv = {}
    pred = solvepredicate(pred)
    for i,v in ipairs(tbl) do
        if pred(v,i,tbl) then
            rv[i] = func(v,i,tbl)
        end
    end
    return rv
end

_G.wrapnumber = function(num,first_bound,second_bound)
    local range_length = math.abs(first_bound-second_bound)+1
    local bottom_val = math.min(first_bound,second_bound)
    return ((num-bottom_val)%range_length)+bottom_val
end

_G.combine_return = function(base,more)
   if type(base) ~= "table" and type(more) ~= "table" then return nil end
   if type(base) ~= "table" then return safetable(more) end
   if type(more) ~= "table" then return safetable(base) end
   base = safetable(base)
   more = safetable(more)
   local final_return = base
   if base.extra then
       base.extra = safetable(base.extra)
       final_return.extra = safetable(combine_return(base.extra,more))
   else
       final_return.extra = more
   end
   return final_return
end'''
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = "engine/object.lua"
pattern = "function Object:extend()"
position = "at"
payload = '''

---@alias CardAreaType ("discard"|"deck"|"hand"|"joker"|"play"|"title_2"|"title"|"voucher"|"consumeable"|"shop"|"SELF"|"any"|"none")

---@alias EventAreaContext ("in_blind_select"|"in_round"|"in_round_bonus"|"in_booster_pack"|"in_card_booster_pack"|"in_planet_booster_pack"|"in_tarot_booster_pack"|"in_joker_booster_pack"|"in_spectral_booster_pack")

---@alias EventAreaStage ("in_starting_blind"|"in_small_blind"|"in_big_blind"|"in_boss_blind")

---@alias CardObjectType ("Default"|"Enhanced"|"Joker"|"Edition"|"Tarot"|"Planet"|"Voucher"|"Spectral"|"Booster"|"None"|"SELF"|"any")

---@alias EventName ("on_update"|"on_blind_select_start"|"on_blind_skip_click"|"on_blind_reroll_click"|"on_blind_click"|"on_blind_select_end_click"|"on_round_start"|"on_discard_click"|"on_discard_card"|"on_discard_end"|"on_discard_draw_card"|"on_discard_draw_end"|"on_play_click"|"on_play_card"|"on_play_end"|"on_score_start"|"on_score_card"|"on_score_lucky"|"on_score_end"|"on_hold_card"|"on_jokers"|"on_jokers_end"|"on_play_discard_card"|"on_play_discard_shatter"|"on_play_discard_end"|"on_play_draw_card"|"on_play_draw_end"|"on_round_end"|"on_round_bonus"|"on_shop_start"|"on_shop_reroll_click"|"on_purchase_click"|"on_create"|"on_add_to_deck"|"on_remove_from_deck"|"on_destroy"|"on_slice"|"on_consumeable"|"on_booster_start"|"on_booster_skip_click"|"on_booster_end"|"on_sell"|"on_shop_end_click"|"on_lose"|"none")

---@alias GameObjectDataType ("event_id"|"chips"|"chip_mod"|"x_chips"|"Xchip_mod"|"mult"|"mult_mod"|"x_mult"|"Xmult_mod"|"dollars"|"interest_cap"|"interest_gain"|"interest_amount"|"debt_size"|"h_plays"|"d_size"|"h_size"|"odds_bonus"|"odds_mult"|"free_rerolls"|"extra"|"discards_since_create"|"hands_played_since_create"|"consecutive_without_face_cards"|"consecutive_without_most_played"|"nine_tally"|"steel_tally"|"stone_tally"|"previous_odds")

_G.GameObjectDataTypes = {"event_id","chips","chip_mod","x_chips","Xchip_mod","mult","mult_mod","x_mult","Xmult_mod","dollars","interest_cap","interest_gain","interest_amount","debt_size","h_plays","d_size","h_size","odds_bonus","odds_mult","free_rerolls","extra","discards_since_create","hands_played_since_create","consecutive_without_face_cards","consecutive_without_most_played","nine_tally","steel_tally","stone_tally","previous_odds"}

_G.dynamic_get = function(obj,...)
    local args = {...}
    return function()
        return table.get(obj,unpack(args))
    end
end

_G.dynamic_set = function(obj,...)
    local args = {...}
    return function(val)
        table.set(obj,unpack(args),val)
    end
end

---@class ListenerConfig
---@field listener_type ("on_trigger")?
---@field self_type CardObjectType?
---@field self_area CardAreaType?
---@field other_type CardObjectType?
---@field other_area CardAreaType?

---@class EventObject
---@field object Card
---@field applied_abilities table
---@field apply_ability fun(field:GameObjectDataType)
---@field resign_ability fun(field:GameObjectDataType)
---@field apply_all_abilities fun()
---@field resign_all_abilities fun()
---@field get_type fun(): CardObjectType?
---@field get_area fun(): CardArea?
---@field get_area_type fun(): CardAreaType?
---@field get fun(field: GameObjectDataType|"type"|"area"|"area_type"): number
---@field set fun(field: GameObjectDataType,val:number,force:boolean?)
---@field tug fun(field: GameObjectDataType,val:number?,operation_func: (fun(a:number,b:number):number)?,force:boolean?)
_G.EventObject = {}

---comment
---@param card Card
---@return EventObject
function EventObject:new(card)
    print("normal")
    local obj = setmetatable({},EventObject)
    obj.object = card
    obj.applied_abilities = {}
    obj.get_type = dynamic_get(card,"config","center","set")
    obj.get_area = dynamic_get(card,"area")
    obj.get_area_type = dynamic_get(card,"area","config","type")
    ---comment
    ---@param field "type"|"area"|"area_type"|GameObjectDataType
    ---@return unknown|nil
    obj.get = function(field)
        if field == "type" then
            return table.get(card,"config","center","set")
        elseif field == "area" then
            return table.get(card,"area")
        elseif field == "area_type" then
            return table.get(card,"area","config","type")
        else
            return table.get(card,"ability","extra",field)
        end
    end
    ---comment
    ---@param field GameObjectDataType
    ---@param val number
    ---@param force boolean? allows you to force deterministic values to be changed
    obj.set = function(field,val,force)
        if ({x_chips=1,Xchip_mod=1,x_mult=1,Xmult_mod=1,odds_mult=1})[field] and not val then val = 1 end
        if not val then val = 0 end
        if ({event_id=1,nine_tally=1,steel_tally=1,stone_tally=1,previous_odds=1,extra=1})[field] and not force then error("tried to tug deterministic value of object without force!") end
        if obj.applied_abilities[field] == nil or obj.applied_abilities[field] == true then
            local field_value = (obj.applied_abilities[field] and table.get(card,"ability","extra",field)) or ({x_chips=1,Xchip_mod=1,x_mult=1,Xmult_mod=1,odds_mult=1})[field] or 0
            if field == "interest_cap" then
                G.GAME.interest_cap = (G.GAME.interest_cap - field_value) + val
            elseif field == "interest_amount" then
                G.GAME.interest_amount = (G.GAME.interest_amount - field_value) + val
            elseif field == "debt_size" then
                G.GAME.bankrupt_at = (G.GAME.bankrupt_at + field_value) - val
            elseif field == "h_plays" then
                G.GAME.round_resets.hands = (G.GAME.round_resets.hands - field_value) + val
            elseif field == "d_size" then
                G.GAME.round_resets.discards = (G.GAME.round_resets.discards - field_value) + val
            elseif field == "h_size" then
                G.hand:change_size(((G.hand.config.card_limit - field_value) + val)-G.hand.config.card_limit)
            elseif field == "odds_bonus" then
                local previous_odds = table.get(card,"ability","extra","previous_odds")
                if not previous_odds then
                    table.set(card,"ability","extra","previous_odds",copy(G.GAME.probabilities))
                    previous_odds = table.get(card,"ability","extra","previous_odds") or error("something went very wrong...")
                end
                for k,v in pairs(G.GAME.probabilities) do
                    if not previous_odds[k] then previous_odds[k] = v end
                    local initial_odds = previous_odds[k]
                    local final_odds = (initial_odds+field_value)*(table.get(card,"ability","extra","odds_mult") or 1)
                    local initial_mult_effect = final_odds/initial_odds
                    local changed_odds = (initial_odds+val)*(table.get(card,"ability","extra","odds_mult") or 1)
                    local changed_mult_effect = changed_odds/initial_odds
                    G.GAME.probabilities[k] = (v/initial_mult_effect)*changed_mult_effect
                end
            elseif field == "odds_mult" then
                local previous_odds = table.get(card,"ability","extra","previous_odds")
                if not previous_odds then
                    table.set(card,"ability","extra","previous_odds",copy(G.GAME.probabilities))
                    previous_odds = table.get(card,"ability","extra","previous_odds") or error("something went very wrong...")
                end
                for k,v in pairs(G.GAME.probabilities) do
                    if not previous_odds[k] then previous_odds[k] = v end
                    local initial_odds = previous_odds[k]
                    local final_odds = (initial_odds+(table.get(card,"ability","extra","odds_bonus") or 0))*field_value
                    local initial_mult_effect = final_odds/initial_odds
                    local changed_odds = (initial_odds+(table.get(card,"ability","extra","odds_bonus") or 0))*val
                    local changed_mult_effect = changed_odds/initial_odds
                    G.GAME.probabilities[k] = (v/initial_mult_effect)*changed_mult_effect
                end
            elseif field == "free_rerolls" then
                G.GAME.current_round.free_rerolls = (G.GAME.current_round.free_rerolls - field_value) + val
                calculate_reroll_cost(true)
            end
        end
        table.set(card,"ability","extra",field,val)
    end
    ---comment
    ---@param field GameObjectDataType
    ---@param val number?
    ---@param operation_func (fun(a:number,b:number): number)?
    ---@param force boolean? allows you to force deterministic values to be changed
    obj.tug = function(field,val,operation_func,force)
        if operation_func == nil then operation_func = function(a,b) return a + b end end
        local field_value = table.get(card,"ability","extra",field) or ({x_chips=1,Xchip_mod=1,x_mult=1,Xmult_mod=1,odds_mult=1})[field] or 0
        local new_value = operation_func(field_value,val or 0)
        obj.set(field,new_value,force)
    end
    obj.apply_ability = function(field)
        if ({event_id=1,nine_tally=1,steel_tally=1,stone_tally=1,previous_odds=1,extra=1})[field] then return end
        if obj.applied_abilities[field] == true then return end
        obj.applied_abilities[field] = nil
        obj.tug(field)
        obj.applied_abilities[field] = true
    end
    obj.resign_ability = function(field)
        if ({event_id=1,nine_tally=1,steel_tally=1,stone_tally=1,previous_odds=1,extra=1})[field] then return end
        if obj.applied_abilities[field] == false then return end
        obj.set(field,({x_chips=1,Xchip_mod=1,x_mult=1,Xmult_mod=1,odds_mult=1})[field] or 0)
        obj.applied_abilities[field] = false
    end
    obj.apply_all_abilities = function()
        for _,field in ipairs(GameObjectDataTypes) do
            obj.apply_ability(field)
        end
    end
    obj.resign_all_abilities = function()
        for _,field in ipairs(GameObjectDataTypes) do
            obj.resign_ability(field)
        end
    end
    return obj
end

---@class EventContext
---@field SELF Object
---@field CONTEXT any
---@field self EventObject
---@field other EventObject

---comment
---@param eventName EventName
---@param config ListenerConfig?
---@param callback fun(context: EventContext): any
function Object:addEventListener(eventName,config,callback)
    config = config or {}
    if not config.self_type then config.self_type = "any" end
    if not config.self_area then config.self_area = "any" end
    if not config.other_type then config.other_type = "SELF" end
    if not config.other_area then config.other_area = "SELF" end
    local function refersToSelf(_config)
        return _config.other_type == "SELF" and _config.other_area == "SELF"
    end
    local function refersToCard(_config)
        return (_config.other_type == "Default" or _config.other_type == "Enhanced" or _config.other_type == "any")
    end
    local function referenceInPlay(_config)
        return (_config.other_area == "play" or _config.other_area == "any")
    end
    local function referenceInDiscard(_config)
        return (_config.other_area == "discard" or _config.other_area == "any")
    end
    local function build_function(cond_func,combine_func)
        if combine_func == nil then combine_func = combine_return end
        return function(old_func)
            return function(_self,card,context)
                local first = nil
                local second = nil
                first = old_func(_self,card,context)
                local this_card = EventObject:new(card)
                local other_card = nil
                if refersToSelf(config) then
                   other_card = EventObject:new(card)
                elseif refersToCard(config) then
                    other_card = EventObject:new(context.other_card)
                else
                    error("Invalid state!")
                end
                if solvepredicate(cond_func)(context,this_card,other_card) then
                    second = callback({
                        SELF = _self,
                        CONTEXT = context,
                        self = this_card,
                        other = other_card
                    })
                end
                return combine_func(first,second)
            end
        end
    end
   table.implement(self,{
    ["@override"] = {
        calculate = ({
            on_jokers = refersToSelf(config) and build_function(function(context) return
                context.cardarea == G.jokers and context.joker_main
            end),
            on_score_card = refersToCard(config) and referenceInPlay(config) and build_function(function(context,_self,other) return 
                other.object and other.get_area() == G.play and context.individual
            end),
            on_round_end = refersToSelf(config) and build_function(function(context) return
                context.end_of_round and not context.individual and not context.repetition
            end),
            on_jokers_end = refersToSelf(config) and build_function(function(context) return 
                context.after and not context.individual and not context.repetition and context.cardarea == G.jokers
            end),
            on_discard_card = refersToCard(config) and referenceInDiscard(config) and build_function(function(context) return 
                context.discard and not context.pre_discard
            end),
            on_discard_click = refersToCard(config) and referenceInDiscard(config) and build_function(function(context) return 
                context.pre_discard and not context.discard
            end),
            on_play_click = refersToSelf(config) and build_function(function(context) return 
                context.before and not context.individual and not context.repetition and context.cardarea == G.jokers
            end),
        })[eventName] or nil,
        calc_dollar_bonus = ({
            on_round_bonus = refersToSelf(config) and build_function(nil,function(a,b) return 
                (a or 0)+(b or 0)
            end),
        })[eventName] or nil,
        add_to_deck = ({
            on_add_to_deck = refersToSelf(config) and build_function(nil,function()end),
        })[eventName] or nil,
        remove_from_deck = ({
            on_remove_from_deck = refersToSelf(config) and build_function(nil,function()end)
        })[eventName] or nil,
    }
   })
end

function Object:extend()'''
match_indent = true
times = 1
[[patches]]
[patches.pattern]
target = "engine/object.lua"
pattern = '''function Object:__call(...)
  local obj = setmetatable({}, self)
  obj:init(...)
  return obj
end'''
position = "after"
payload = '''


---NaN literal
---@type number
_G.NaN = 0/0

---Infinity literal
---@type number
_G.Infinity = 1/0

---Returns true if <code>object</code> cannot be operated with a number or if <code>object</code> is <code>NaN</code>.
---@param object any
---@return boolean
_G.isNaN = function(object)
   if getmetatable(object) == Number then
      return object.value ~= object.value
   else
      return object ~= object
   end
end

---Returns true if <code>object</code> cannot be operated with a number or if <code>object</code> is <code>WaN</code>.
---@param object any
---@return boolean
_G.isWaN = function(object)
   return getmetatable(object) == Number and object.value == WaN.value or false
end

---@type fun(e: any, base:any): number?
local original_tonumber = tonumber
tonumber = function(e,base)
   local rv = original_tonumber(e,base)
   if rv == nil and getmetatable(e) == Number then
      if isWaN(e) then
         return WaN
      else
         return e.value
      end
   elseif rv ~= nil then
      return rv
   else
      return nil
   end
end

local original_type = type
type = function(obj)
   local rv = original_type(obj)
   if rv == "table" and getmetatable(obj) == Number then
      return "number"
   else
      return rv
   end
end

---@class Number
---@field value number|"-wan"
_G.Number = {}
Number.__index = Number

---A wrapper class for all numbers to allow for special values (like WaN) to exist
---@param other any
---@return Number?
function Number:new(other)
   if not other then
      return nil
   elseif isWaN(other) then
      return WaN
   elseif getmetatable(other) == Number then
      local instance = Number:new(other.value)
      return instance
   elseif other == "-wan" then
      local instance = setmetatable({},Number)
      instance.value = "-wan"
      return instance
   else
      if type(other) ~= "number" then return nil end
      local instance = setmetatable({},Number)
      instance.value = other
      return instance
   end
end

function Number:__unm()
   if isWaN(self) then return WaN end
   return Number:new(-tonumber(self))
end

function Number:__mod(other)
   if isWaN(self) then return WaN end
   if isWaN(other) then return WaN end
   return Number:new(tonumber(self) % tonumber(other))
end

function Number:__pow(other)
   if isWaN(self) then return WaN end
   if isWaN(other) then return WaN end
   return Number:new(tonumber(self) ^ tonumber(other))
end

function Number:__add(other)
   if isWaN(self) then return WaN end
   if isWaN(other) then return WaN end
   return Number:new(tonumber(self) + tonumber(other))
end

function Number:__sub(other)
   if isWaN(self) then return WaN end
   if isWaN(other) then return WaN end
   return Number:new(tonumber(self) - tonumber(other))
end

function Number:__mul(other)
   if isWaN(self) then return WaN end
   if isWaN(other) then return WaN end
   return Number:new(tonumber(self) * tonumber(other))
end

function Number:__div(other)
   if isWaN(self) then return WaN end
   if isWaN(other) then return WaN end
   return Number:new(tonumber(self) / tonumber(other))
end

function Number:__tostring()
   if isWaN(self) then return WaN.value end
   return tostring(tonumber(self))
end

function Number.__concat(a,b)
   return tostring(a) .. tostring(b)
end

function Number:__eq(other)
   if isWaN(self) then return not isNaN(other) end
   if isWaN(other) then return not isNaN(self) end
   return tonumber(self) == tonumber(other)
end

function Number:__lt(other)
   if isWaN(self) then return not isNaN(other) end
   if isWaN(other) then return not isNaN(self) end
   return tonumber(self) < tonumber(other)
end

function Number:__le(other)
   if isWaN(self) then return not isNaN(other) end
   if isWaN(other) then return not isNaN(self) end
   return tonumber(self) <= tonumber(other)
end

---Wild number literal
---@type Number
_G.WaN = Number:new("-wan") or error("Mistakes have been made...")

---Evaluates falsy objects according to javascript rules.
---@param any any
---@return boolean
_G.bool = function(any)
    if not any or (any == Number:new(0) and not isWaN(any)) or (type(any)=="number" and isNaN(any)) or any == "" then return false end
    return true
end
'''
match_indent = true
times = 1