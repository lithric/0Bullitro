[manifest]
version = "1.0.0"
dump_lua = true
priority = 0


#fixing engine
[[patches]]
[patches.regex]
target = "engine/controller.lua"
pattern = "((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+) (>|<|>=|<=|==) ((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+)"
position = "at"
payload = "(Number and Number:new($1) or ($1)) $2 (Number and Number:new($3) or ($3))"
[[patches]]
[patches.regex]
target = "engine/moveable.lua"
pattern = "((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+) (>|<|>=|<=|==) ((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+)"
position = "at"
payload = "(Number and Number:new($1) or ($1)) $2 (Number and Number:new($3) or ($3))"
[[patches]]
[patches.regex]
target = "engine/sound_manager.lua"
pattern = "((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+) (>|<|>=|<=|==) ((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+)"
position = "at"
payload = "(Number and Number:new($1) or ($1)) $2 (Number and Number:new($3) or ($3))"
[[patches]]
[patches.regex]
target = "engine/text.lua"
pattern = "((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+) (>|<|>=|<=|==) ((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+)"
position = "at"
payload = "(Number and Number:new($1) or ($1)) $2 (Number and Number:new($3) or ($3))"
[[patches]]
[patches.regex]
target = "engine/ui.lua"
pattern = "((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+) (>|<|>=|<=|==) ((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+)"
position = "at"
payload = "(Number and Number:new($1) or ($1)) $2 (Number and Number:new($3) or ($3))"

#fixing functions
[[patches]]
[patches.regex]
target = "functions/button_callbacks.lua"
pattern = "((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+) (>|<|>=|<=|==) ((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+)"
position = "at"
payload = "(Number and Number:new($1) or ($1)) $2 (Number and Number:new($3) or ($3))"
# [[patches]]
# [patches.regex]
# target = "functions/common_events.lua"
# pattern = "<= math\\.max\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)"
# position = "at"
# payload = "<= (Number and Number:new(math.max($1)) or (math.max($1)))"
[[patches]]
[patches.regex]
target = "functions/common_events.lua"
pattern = "((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+) (>|<|>=|<=|==) ((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+)"
position = "at"
payload = "(Number and Number:new($1) or ($1)) $2 (Number and Number:new($3) or ($3))"
[[patches]]
[patches.regex]
target = "functions/misc_functions.lua"
pattern = "((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+) (>|<|>=|<=|==) ((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+)"
position = "at"
payload = "(Number and Number:new($1) or ($1)) $2 (Number and Number:new($3) or ($3))"
[[patches]]
[patches.regex]
target = "functions/state_events.lua"
pattern = "((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+) (>|<|>=|<=|==) ((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+)"
position = "at"
payload = "(Number and Number:new($1) or ($1)) $2 (Number and Number:new($3) or ($3))"
[[patches]]
[patches.regex]
target = "functions/UI_definitions.lua"
pattern = "((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+) (>|<|>=|<=|==) ((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+)"
position = "at"
payload = "(Number and Number:new($1) or ($1)) $2 (Number and Number:new($3) or ($3))"

#fixing rest
[[patches]]
[patches.regex]
target = "back.lua"
pattern = "((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+) (>|<|>=|<=|==) ((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+)"
position = "at"
payload = "(Number and Number:new($1) or ($1)) $2 (Number and Number:new($3) or ($3))"
[[patches]]
[patches.regex]
target = "blind.lua"
pattern = "((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+) (>|<|>=|<=|==) ((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+)"
position = "at"
payload = "(Number and Number:new($1) or ($1)) $2 (Number and Number:new($3) or ($3))"
[[patches]]
[patches.regex]
target = "card.lua"
pattern = "((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+) (>|<|>=|<=|==) ((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+)"
position = "at"
payload = "(Number and Number:new($1) or ($1)) $2 (Number and Number:new($3) or ($3))"
[[patches]]
[patches.regex]
target = "cardarea.lua"
pattern = "((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+) (>|<|>=|<=|==) ((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+)"
position = "at"
payload = "(Number and Number:new($1) or ($1)) $2 (Number and Number:new($3) or ($3))"
[[patches]]
[patches.regex]
target = "game.lua"
pattern = "((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+) (>|<|>=|<=|==) ((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+)"
position = "at"
payload = "(Number and Number:new($1) or ($1)) $2 (Number and Number:new($3) or ($3))"
[[patches]]
[patches.regex]
target = "main.lua"
pattern = "((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+) (>|<|>=|<=|==) ((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+)"
position = "at"
payload = "(Number and Number:new($1) or ($1)) $2 (Number and Number:new($3) or ($3))"
[[patches]]
[patches.regex]
target = "tag.lua"
pattern = "((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+) (>|<|>=|<=|==) ((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+)"
position = "at"
payload = "(Number and Number:new($1) or ($1)) $2 (Number and Number:new($3) or ($3))"

# adding for annotations

# top level
[[patches]]
[patches.pattern]
target = "card_character.lua"
pattern = "ϖ"
position = "at"
payload = "ϖ"
match_indent = true
times = 1
[[patches]]
[patches.pattern]
target = "challenges.lua"
pattern = "ϖ"
position = "at"
payload = "ϖ"
match_indent = true
times = 1
[[patches]]
[patches.pattern]
target = "challenges.lua"
pattern = "ϖ"
position = "at"
payload = "ϖ"
match_indent = true
times = 1
[[patches]]
[patches.pattern]
target = "conf.lua"
pattern = "ϖ"
position = "at"
payload = "ϖ"
match_indent = true
times = 1

# engine
[[patches]]
[patches.pattern]
target = "engine/event.lua"
pattern = "ϖ"
position = "at"
payload = "ϖ"
match_indent = true
times = 1
[[patches]]
[patches.pattern]
target = "engine/http_manager.lua"
pattern = "ϖ"
position = "at"
payload = "ϖ"
match_indent = true
times = 1
[[patches]]
[patches.pattern]
target = "engine/node.lua"
pattern = "ϖ"
position = "at"
payload = "ϖ"
match_indent = true
times = 1
[[patches]]
[patches.pattern]
target = "engine/object.lua"
pattern = "ϖ"
position = "at"
payload = "ϖ"
match_indent = true
times = 1
[[patches]]
[patches.pattern]
target = "engine/particles.lua"
pattern = "ϖ"
position = "at"
payload = "ϖ"
match_indent = true
times = 1
[[patches]]
[patches.pattern]
target = "engine/profile.lua"
pattern = "ϖ"
position = "at"
payload = "ϖ"
match_indent = true
times = 1
[[patches]]
[patches.pattern]
target = "engine/string_packer.lua"
pattern = "ϖ"
position = "at"
payload = "ϖ"
match_indent = true
times = 1

# functions
[[patches]]
[patches.pattern]
target = "functions/test_functions.lua"
pattern = "ϖ"
position = "at"
payload = "ϖ"
match_indent = true
times = 1



# other
# moveable
[[patches]]
[patches.pattern]
target = "engine/moveable.lua"
pattern = "---@class Moveable: Node"
position = "at"
payload = '''

---@class RoleObject
---@field offset Position2D
---@field role_type ('Major'|'Minor'|'Glued')?
---@field bond ('Strong'|'Weak')?
---@field xy_bond ('Strong'|'Weak')?
---@field wh_bond ('Strong'|'Weak')?
---@field r_bond ('Strong'|'Weak')?
---@field scale_bond ('Strong'|'Weak')?
---@field type ('tl'|'tm'|'tr'|'cl'|'cm'|'cr'|'bl'|'bm'|'br'|'tli'|'tmi'|'tri'|'cli'|'cmi'|'cri'|'bli'|'bmi'|'bri'|string)?
---@field draw_major Moveable?
---@field major Moveable?

---@class Moveable: Node
---@field role RoleObject
---@field zoom number?
---@operator call:Moveable'''
match_indent = true
times = 1
[[patches]]
[patches.pattern]
target = "engine/moveable.lua"
pattern = "---@param args {T: table, container: Node}"
position = "at"
payload = '''

---@function
---@param X ({T:[number,number,number,number]}|number)?
---@param Y number?
---@param W number?
---@param H number?'''
match_indent = true
times = 1
[[patches]]
[patches.pattern]
target = "engine/moveable.lua"
pattern = "---@param args {major: Moveable, bond: string, offset: table, type: string}"
position = "at"
payload = "---@param args (RoleObject|Moveable)?"
match_indent = true
times = 1

#UI
[[patches]]
[patches.pattern]
target = "engine/ui.lua"
pattern = "--Class"
position = "at"
payload = '''

---@class UIBox: Moveable
---@operator call:UIBox'''
match_indent = true
times = 1
[[patches]]
[patches.pattern]
target = "engine/ui.lua"
pattern = "---@param args {T: table, definition: table, config: table}"
position = "at"
payload = "---@param args UIBox|Moveable"
match_indent = true
times = 1
[[patches]]
[patches.pattern]
target = "engine/ui.lua"
pattern = "--Class"
position = "at"
payload = '''

---@alias UITransform {Root:any,T:any,O:any,B:any,C:any,R:any}
---@class UIElement: Moveable
---@field parent UIElement
---@operator call:UIElement'''
match_indent = true
times = 1
[[patches]]
[patches.pattern]
target = "engine/ui.lua"
pattern = "--Class Methods"
position = "at"
payload = '''

---@function
---@param parent (UIElement|UIBox)
---@param new_UIBox UIBox
---@param new_UIT UITransform
---@param config table'''
match_indent = true
times = 1

#node
[[patches]]
[patches.pattern]
target = "engine/node.lua"
pattern = "---@class Node"
position = "at"
payload = '''

---@alias Transform2D {x:number|0,y:number|0,w:number|1,h:number|1,r:number|0,scale:number|1}
---@alias ChildNodes {d_popup: UIBox,h_popup: UIBox, alert: UIBox,rest...:Node}

---@class Node: Object
---@field T Transform2D
---@field CT Transform2D
---@field VT Transform2D?
---@field DEBUG_VALUE string?
---@field CALCING boolean?
---@field children ChildNodes
---@operator call:Node'''
match_indent = true
times = 1
[[patches]]
[patches.pattern]
target = "engine/node.lua"
pattern = "---@param args {T: table, container: Node}"
position = "at"
payload = '''---@param args {T: [number?,number?,number?,number?,number?,number?]|{x:number?,y:number?,w:number?,h:number?,r:number?,scale:number?}, container: Node}'''
match_indent = true
times = 1

#controller
[[patches]]
[patches.pattern]
target = "engine/controller.lua"
pattern = "---@class Controller"
position = "at"
payload = '''

---@alias Position2D {x:number,y:number}

---@class ControlHandle
---@field handled boolean
---@field target (Card|Node|UIElement)?
---@field time number?
---@field prev_target (Card|Node|UIElement)?
---@field T Position2D?

---@class Controller: Object
---@field clicked ControlHandle
---@field focused ControlHandle
---@field dragging ControlHandle
---@field hovering ControlHandle
---@field released_on ControlHandle
---@field cursor_down ControlHandle
---@field cursor_up ControlHandle
---@field cursor_hover ControlHandle
---@operator call:Controller'''
match_indent = true
times = 1

#object
[[patches]]
[patches.pattern]
target = "engine/object.lua"
pattern = "Object = {}"
position = "at"
payload = '''

---@class Object
---@operator call:Object
Object = {}'''
match_indent = true
times = 1

#event
[[patches]]
[patches.pattern]
target = "engine/event.lua"
pattern = "--Class"
position = "at"
payload = '''

---@class Event:Object
---@operator call:Event'''
match_indent = true
times = 1
[[patches]]
[patches.pattern]
target = "engine/event.lua"
pattern = "--Class Methods"
position = "at"
payload = '''

---@class EventConfig
---@field blockable boolean?
---@field blocking boolean?
---@field trigger ('immediate'|'ease'|'condition'|'after'|'before')?
---@field start_timer boolean?
---@field no_delete boolean?
---@field delay number?
---@field timer ('BACKGROUND'|'REAL'|'REAL_SHADER'|'TOTAL'|'UPTIME')?
---@field ease ('lerp'|'elastic'|'quad')?
---@field ease_to number?
---@field func (fun(progress: number): boolean)?
---@field ref_table table?
---@field ref_value string?
---@field stop_val any?
---@field pause_force boolean?

---@function
---@param config EventConfig'''
match_indent = true
times = 1
[[patches]]
[patches.pattern]
target = "engine/event.lua"
pattern = "--Class"
position = "at"
payload = '''

---@class EventManager:Object
---@operator call:EventManager'''
match_indent = true
times = 1


#Big object patch
[[patches]]
[patches.pattern]
target = "engine/object.lua"
pattern = "Object = {}"
position = "at"
payload = '''Object = {}

---Removes the leading and trailing whitespace characters from a string.
---@param self string
---@return string
function string.trim(self)
    return self:match("^%s*(.-)%s*$")
end

---Converts <code>object</code> into a number using javascript rules (nil is undefined).<br>
---Returns <code>NaN</code> if <code>object</code> could not be converted into a number.
---@param object any
---@return number|Number|nil
_G.numer = function(object)
    if type(object) == "number" then return object end
    if type(object) == "boolean" then return object and 1 or 0 end
    if type(object) == "string" then
        if object == "Infinity" then return Infinity end
        if object == "-Infinity" then return -Infinity end
        if object == "" then return 0 end
    end
    return tonumber(object) or NaN
end

---comment
---@param v any
---@param ... any
---@return Card
_G.safetypecard = function(v,...)
    assert(getmetatable(v)==Card,...)
    return v
end

---comment
---@param str any
---@param ... any
---@return string
_G.safestr = function(str,...)
    assert(type(str) == "string",...)
    return str
end


---comment
---@param tbl any
---@param ... any
---@return table
_G.safetable = function(tbl,...)
    assert(type(tbl) == "table",...)
    return tbl
end

---comment
---@param bl any
---@param ... any
---@return boolean
_G.safebool = function(bl,...)
    assert(type(bl) == "boolean",...)
    return bl
end


_G.dump = function(o)
    if type(o) == 'table' then
        local s = '{ '
        for k,v in pairs(o) do
            if type(k) ~= 'number' then k = '"'..k..'"' end
            s = s .. '['..k..'] = ' .. dump(v) .. ','
        end
        return s .. '} '
    else
        return tostring(o)
    end
end

_G.copy = function(obj, seen)
    if type(obj) ~= 'table' then return obj end
    if seen and seen[obj] then return seen[obj] end
    local s = seen or {}
    local res = setmetatable({}, getmetatable(obj))
    s[obj] = res
    for k, v in pairs(obj) do res[copy(k, s)] = copy(v, s) end
    return res
end

_G.solvepredicate = function(pred)
    if pred == nil then
        pred = function() return true end
    end
    if type(pred) == "boolean" then
        if pred then
            pred = function(v)
                return bool(v)
            end
        else
            pred = function(v)
                return not bool(v)
            end
        end
    end
    if type(pred) == "table" then
        local comparisonType = pred.match or "and"
        if comparisonType == "and" then
            local predicates = pred
            pred = function(...)
                for i,cond in ipairs(predicates) do
                    if not bool(solvepredicate(cond)(...)) then
                        return false
                    end
                end
                return true
            end
        elseif comparisonType == "or" then
            local predicates = pred
            pred = function(...)
                for i,cond in ipairs(predicates) do
                    if bool(solvepredicate(cond)(...)) then
                        return true
                    end
                end
                return false
            end
        end
    end
    if type(pred) ~= "function" then
        local val = pred
        pred = function(v)
            return v == val
        end
    end
    return pred
end

---Returns true if some value inside the list matched the predicate.
---@param tbl table
---@param pred any
---@return boolean
function table.some(tbl,pred)
    pred = solvepredicate(pred)
    for i,v in ipairs(tbl) do
        if pred(v,i,tbl) then
            return true
        end
    end
    return false
end

---Returns true if every value inside the list matched the predicate.
---@param tbl any
---@param pred any
---@return boolean
function table.every(tbl,pred)
   pred = solvepredicate(pred)
   for i,v in ipairs(tbl) do
       if not pred(v,i,tbl) then
           return false
       end
   end
   return true
end

function table.implement(tbl,impl)
    for k,v in pairs(impl) do
        if k == "@override" then goto continue end
        if tbl[k] == nil then
            tbl[k] = v
        elseif type(v) == "table" and type(tbl[k]) == "table" then
            table.implement(tbl[k],v)
        end
        ::continue::
    end
    for k,v in pairs(impl["@override"] or {}) do
        if type(tbl[k]) == "table" and type(v) == "table" then
            table.implement(tbl[k],{["@override"] = v})
        elseif (type(tbl[k]) == "function" or tbl[k] == nil) and type(v) == "function" then
            tbl[k] = v(tbl[k] or function() end)
        else
            tbl[k] = v
        end
    end
end

function table.get(tbl,...)
    local got = nil
    for i,v in ipairs({...}) do
         if got == nil then
            got = tbl
         end
         got = got[v]
         if got == nil then
            return got
         end
    end
    return got
end

---Returns the amount of entries in the list that matched the filter.
---@param tbl table
---@param pred any
---@return integer
function table.count(tbl,pred)
    pred = solvepredicate(pred)
    local count = 0
    for i,v in ipairs(tbl) do
        if pred(v,i,tbl) then
            count = count + 1
        end
    end
    return count
end

---Returns a new list with all the entries of the list that passed the filter.
---@generic H: table
---@param tbl `H`
---@param pred any
---@return H
function table.filter(tbl,pred)
    local rv = {}
    pred = solvepredicate(pred)
    for i,v in ipairs(tbl) do
        if pred(v,i,tbl) then
            table.insert(rv,v)
        end
    end
    return rv
end

---Returns the sum of all the values inside the list.
---@param tbl table
---@param pred any
---@return number
function table.sum(tbl,pred)
    local sum = 0
    pred = solvepredicate(pred)
    for i,v in ipairs(tbl) do
        if pred(v,i,tbl) then
            sum = sum + numer(v)
        end
    end
    return sum
end

---Returns a new list with each value mapped with the mapping function.
---@generic H: table
---@param tbl `H`
---@generic T
---@param func fun(value: any,index: integer,table: H): `T`
---@param pred any
---@return T[]
function table.map(tbl,func,pred)
    local rv = {}
    pred = solvepredicate(pred)
    for i,v in ipairs(tbl) do
        if pred(v,i,tbl) then
            rv[i] = func(v,i,tbl)
        end
    end
    return rv
end

_G.wrapnumber = function(num,first_bound,second_bound)
    local range_length = math.abs(first_bound-second_bound)+1
    local bottom_val = math.min(first_bound,second_bound)
    return ((num-bottom_val)%range_length)+bottom_val
end

_G.combine_return = function(base,more)
   if type(base) ~= "table" and type(more) ~= "table" then return nil end
   if type(base) ~= "table" then return safetable(more) end
   if type(more) ~= "table" then return safetable(base) end
   base = safetable(base)
   more = safetable(more)
   local final_return = base
   if base.extra then
       base.extra = safetable(base.extra)
       final_return.extra = safetable(combine_return(base.extra,more))
   else
       final_return.extra = more
   end
   return final_return
end'''
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = "engine/object.lua"
pattern = "function Object:extend()"
position = "at"
payload = '''

---@alias EventAreaType ("blind"|"round"|"shop"|"booster"|"blind_small"|"blind_big"|"blind_boss"|"booster_card"|"booster_planet"|"booster_tarot"|"booster_joker"|"booster_spectral")?

---@alias EventObjectType ("card"|"planet"|"tarot"|"joker"|"spectral"|"voucher")?

---@class ListenerConfig
---@field listener_context ("on_trigger")?
---@field object_context EventObjectType
---@field area_context EventAreaType

---@class EventContext
---@field self Card
---@field cardObject Card
---@field areaObject CardArea
---@field cardType EventObjectType
---@field areaType EventAreaType

---comment
---@param eventName "on_update"|"on_blind_select_start"|"on_blind_skip_click"|"on_blind_reroll_click"|"on_blind_click"|"on_blind_select_end_click"|"on_round_start"|"on_discard_click"|"on_discard_card"|"on_discard_end"|"on_discard_draw_card"|"on_discard_draw_end"|"on_play_click"|"on_play_card"|"on_play_end"|"on_score_start"|"on_score_card"|"on_score_lucky"|"on_score_end"|"on_hold_card"|"on_jokers"|"on_jokers_end"|"on_play_discard_card"|"on_play_discard_shatter"|"on_play_discard_end"|"on_play_draw_card"|"on_play_draw_end"|"on_round_end"|"on_shop_start"|"on_shop_reroll_click"|"on_purchase_click"|"on_create"|"on_add_to_deck"|"on_consumeable"|"on_booster_start"|"on_booster_skip_click"|"on_booster_end"|"on_sell"|"on_shop_end_click"|"on_lose"
---@param listenerConfig ListenerConfig?
---@param callback fun(context: EventContext): any
function Object:addEventListener(eventName,listenerConfig,callback)
   listenerConfig = listenerConfig or {}
   if not listenerConfig.object_context then listenerConfig.object_context = "joker" end
   if not listenerConfig.area_context then listenerConfig.area_context = "round" end
   if eventName == "on_jokers" and listenerConfig.area_context == "round" then
      table.implement(self,{
         ["@override"] = {
            calculate = function(old_calculate)
               return function(_self,card,context)
                  local first = nil
                  local second = nil
                  first = old_calculate(_self,card,context)
                  if context.cardarea == G.jokers and context.joker_main then
                     second = callback({
                        self = _self,
                        cardObject = card,
                        context = context,
                        cardType = listenerConfig.object_context,
                        areaObject = G.jokers,
                        areaType = listenerConfig.area_context,
                     })
                  end
                  return combine_return(first,second)
               end
            end
         }
      })
   end
end

function Object:extend()'''
match_indent = true
times = 1
[[patches]]
[patches.pattern]
target = "engine/object.lua"
pattern = '''function Object:__call(...)
  local obj = setmetatable({}, self)
  obj:init(...)
  return obj
end'''
position = "after"
payload = '''


---NaN literal
---@type number
_G.NaN = 0/0

---Infinity literal
---@type number
_G.Infinity = 1/0

---Returns true if <code>object</code> cannot be operated with a number or if <code>object</code> is <code>NaN</code>.
---@param object any
---@return boolean
_G.isNaN = function(object)
   if getmetatable(object) == Number then
      return object.value ~= object.value
   else
      return object ~= object
   end
end

---Returns true if <code>object</code> cannot be operated with a number or if <code>object</code> is <code>WaN</code>.
---@param object any
---@return boolean
_G.isWaN = function(object)
   return getmetatable(object) == Number and object.value == WaN.value or false
end

---@type fun(e: any, base:any): number?
local original_tonumber = tonumber
tonumber = function(e,base)
   local rv = original_tonumber(e,base)
   if rv == nil and getmetatable(e) == Number then
      if isWaN(e) then
         return WaN
      else
         return e.value
      end
   elseif rv ~= nil then
      return rv
   else
      return nil
   end
end

local original_type = type
type = function(obj)
   local rv = original_type(obj)
   if rv == "table" and getmetatable(obj) == Number then
      return "number"
   else
      return rv
   end
end

---@class Number
---@field value number|"-wan"
_G.Number = {}
Number.__index = Number

---A wrapper class for all numbers to allow for special values (like WaN) to exist
---@param other any
---@return Number?
function Number:new(other)
   if not other then
      return nil
   elseif isWaN(other) then
      return WaN
   elseif getmetatable(other) == Number then
      local instance = Number:new(other.value)
      return instance
   elseif other == "-wan" then
      local instance = setmetatable({},Number)
      instance.value = "-wan"
      return instance
   else
      if type(other) ~= "number" then return nil end
      local instance = setmetatable({},Number)
      instance.value = other
      return instance
   end
end

function Number:__unm()
   if isWaN(self) then return WaN end
   return Number:new(-tonumber(self))
end

function Number:__mod(other)
   if isWaN(self) then return WaN end
   if isWaN(other) then return WaN end
   return Number:new(tonumber(self) % tonumber(other))
end

function Number:__pow(other)
   if isWaN(self) then return WaN end
   if isWaN(other) then return WaN end
   return Number:new(tonumber(self) ^ tonumber(other))
end

function Number:__add(other)
   if isWaN(self) then return WaN end
   if isWaN(other) then return WaN end
   return Number:new(tonumber(self) + tonumber(other))
end

function Number:__sub(other)
   if isWaN(self) then return WaN end
   if isWaN(other) then return WaN end
   return Number:new(tonumber(self) - tonumber(other))
end

function Number:__mul(other)
   if isWaN(self) then return WaN end
   if isWaN(other) then return WaN end
   return Number:new(tonumber(self) * tonumber(other))
end

function Number:__div(other)
   if isWaN(self) then return WaN end
   if isWaN(other) then return WaN end
   return Number:new(tonumber(self) / tonumber(other))
end

function Number:__tostring()
   if isWaN(self) then return WaN.value end
   return tostring(tonumber(self))
end

function Number.__concat(a,b)
   return tostring(a) .. tostring(b)
end

function Number:__eq(other)
   if isWaN(self) then return not isNaN(other) end
   if isWaN(other) then return not isNaN(self) end
   return tonumber(self) == tonumber(other)
end

function Number:__lt(other)
   if isWaN(self) then return not isNaN(other) end
   if isWaN(other) then return not isNaN(self) end
   return tonumber(self) < tonumber(other)
end

function Number:__le(other)
   if isWaN(self) then return not isNaN(other) end
   if isWaN(other) then return not isNaN(self) end
   return tonumber(self) <= tonumber(other)
end

---Wild number literal
---@type Number
_G.WaN = Number:new("-wan") or error("Mistakes have been made...")

---Evaluates falsy objects according to javascript rules.
---@param any any
---@return boolean
_G.bool = function(any)
    if not any or (any == Number:new(0) and not isWaN(any)) or (type(any)=="number" and isNaN(any)) or any == "" then return false end
    return true
end
'''
match_indent = true
times = 1