[manifest]
version = "1.0.0"
dump_lua = true
priority = 0


#fixing engine
[[patches]]
[patches.regex]
target = "engine/controller.lua"
pattern = "((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+) (>|<|>=|<=|==) ((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+)"
position = "at"
payload = "(Number and Number:new($1) or ($1)) $2 (Number and Number:new($3) or ($3))"
[[patches]]
[patches.regex]
target = "engine/moveable.lua"
pattern = "((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+) (>|<|>=|<=|==) ((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+)"
position = "at"
payload = "(Number and Number:new($1) or ($1)) $2 (Number and Number:new($3) or ($3))"
[[patches]]
[patches.regex]
target = "engine/sound_manager.lua"
pattern = "((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+) (>|<|>=|<=|==) ((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+)"
position = "at"
payload = "(Number and Number:new($1) or ($1)) $2 (Number and Number:new($3) or ($3))"
[[patches]]
[patches.regex]
target = "engine/text.lua"
pattern = "((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+) (>|<|>=|<=|==) ((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+)"
position = "at"
payload = "(Number and Number:new($1) or ($1)) $2 (Number and Number:new($3) or ($3))"
[[patches]]
[patches.regex]
target = "engine/ui.lua"
pattern = "((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+) (>|<|>=|<=|==) ((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+)"
position = "at"
payload = "(Number and Number:new($1) or ($1)) $2 (Number and Number:new($3) or ($3))"

#fixing functions
[[patches]]
[patches.regex]
target = "functions/button_callbacks.lua"
pattern = "((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+) (>|<|>=|<=|==) ((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+)"
position = "at"
payload = "(Number and Number:new($1) or ($1)) $2 (Number and Number:new($3) or ($3))"
# [[patches]]
# [patches.regex]
# target = "functions/common_events.lua"
# pattern = "<= math\\.max\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)"
# position = "at"
# payload = "<= (Number and Number:new(math.max($1)) or (math.max($1)))"
[[patches]]
[patches.regex]
target = "functions/common_events.lua"
pattern = "((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+) (>|<|>=|<=|==) ((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+)"
position = "at"
payload = "(Number and Number:new($1) or ($1)) $2 (Number and Number:new($3) or ($3))"
[[patches]]
[patches.regex]
target = "functions/misc_functions.lua"
pattern = "((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+) (>|<|>=|<=|==) ((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+)"
position = "at"
payload = "(Number and Number:new($1) or ($1)) $2 (Number and Number:new($3) or ($3))"
[[patches]]
[patches.regex]
target = "functions/state_events.lua"
pattern = "((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+) (>|<|>=|<=|==) ((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+)"
position = "at"
payload = "(Number and Number:new($1) or ($1)) $2 (Number and Number:new($3) or ($3))"
[[patches]]
[patches.regex]
target = "functions/UI_definitions.lua"
pattern = "((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+) (>|<|>=|<=|==) ((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+)"
position = "at"
payload = "(Number and Number:new($1) or ($1)) $2 (Number and Number:new($3) or ($3))"

#fixing rest
[[patches]]
[patches.regex]
target = "back.lua"
pattern = "((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+) (>|<|>=|<=|==) ((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+)"
position = "at"
payload = "(Number and Number:new($1) or ($1)) $2 (Number and Number:new($3) or ($3))"
[[patches]]
[patches.regex]
target = "blind.lua"
pattern = "((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+) (>|<|>=|<=|==) ((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+)"
position = "at"
payload = "(Number and Number:new($1) or ($1)) $2 (Number and Number:new($3) or ($3))"
[[patches]]
[patches.regex]
target = "card.lua"
pattern = "((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+) (>|<|>=|<=|==) ((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+)"
position = "at"
payload = "(Number and Number:new($1) or ($1)) $2 (Number and Number:new($3) or ($3))"
[[patches]]
[patches.regex]
target = "cardarea.lua"
pattern = "((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+) (>|<|>=|<=|==) ((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+)"
position = "at"
payload = "(Number and Number:new($1) or ($1)) $2 (Number and Number:new($3) or ($3))"
[[patches]]
[patches.regex]
target = "game.lua"
pattern = "((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+) (>|<|>=|<=|==) ((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+)"
position = "at"
payload = "(Number and Number:new($1) or ($1)) $2 (Number and Number:new($3) or ($3))"
[[patches]]
[patches.regex]
target = "main.lua"
pattern = "((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+) (>|<|>=|<=|==) ((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+)"
position = "at"
payload = "(Number and Number:new($1) or ($1)) $2 (Number and Number:new($3) or ($3))"
[[patches]]
[patches.regex]
target = "tag.lua"
pattern = "((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+) (>|<|>=|<=|==) ((?:#|(?:not )+)?[A-Za-z_]\\w*(?:\\[\\S+?\\])*(?:\\.[A-Za-z_]\\w*(?:\\[\\S+?\\])*)*(?:[\\:\\.][A-Za-z_]\\w*\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)|\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))?|[\\d\\.]+)"
position = "at"
payload = "(Number and Number:new($1) or ($1)) $2 (Number and Number:new($3) or ($3))"

# adding for annotations

# top level
[[patches]]
[patches.pattern]
target = "card_character.lua"
pattern = "ϖ"
position = "at"
payload = "ϖ"
match_indent = true
times = 1
[[patches]]
[patches.pattern]
target = "challenges.lua"
pattern = "ϖ"
position = "at"
payload = "ϖ"
match_indent = true
times = 1
[[patches]]
[patches.pattern]
target = "challenges.lua"
pattern = "ϖ"
position = "at"
payload = "ϖ"
match_indent = true
times = 1
[[patches]]
[patches.pattern]
target = "conf.lua"
pattern = "ϖ"
position = "at"
payload = "ϖ"
match_indent = true
times = 1

# engine
[[patches]]
[patches.pattern]
target = "engine/event.lua"
pattern = "ϖ"
position = "at"
payload = "ϖ"
match_indent = true
times = 1
[[patches]]
[patches.pattern]
target = "engine/http_manager.lua"
pattern = "ϖ"
position = "at"
payload = "ϖ"
match_indent = true
times = 1
[[patches]]
[patches.pattern]
target = "engine/node.lua"
pattern = "ϖ"
position = "at"
payload = "ϖ"
match_indent = true
times = 1
[[patches]]
[patches.pattern]
target = "engine/object.lua"
pattern = "ϖ"
position = "at"
payload = "ϖ"
match_indent = true
times = 1
[[patches]]
[patches.pattern]
target = "engine/particles.lua"
pattern = "ϖ"
position = "at"
payload = "ϖ"
match_indent = true
times = 1
[[patches]]
[patches.pattern]
target = "engine/profile.lua"
pattern = "ϖ"
position = "at"
payload = "ϖ"
match_indent = true
times = 1
[[patches]]
[patches.pattern]
target = "engine/string_packer.lua"
pattern = "ϖ"
position = "at"
payload = "ϖ"
match_indent = true
times = 1

# functions
[[patches]]
[patches.pattern]
target = "functions/test_functions.lua"
pattern = "ϖ"
position = "at"
payload = "ϖ"
match_indent = true
times = 1



# other
# moveable
[[patches]]
[patches.pattern]
target = "engine/moveable.lua"
pattern = "---@class Moveable: Node"
position = "at"
payload = '''

---@class RoleObject
---@field offset Position2D
---@field role_type ('Major'|'Minor'|'Glued')?
---@field bond ('Strong'|'Weak')?
---@field xy_bond ('Strong'|'Weak')?
---@field wh_bond ('Strong'|'Weak')?
---@field r_bond ('Strong'|'Weak')?
---@field scale_bond ('Strong'|'Weak')?
---@field type ('tl'|'tm'|'tr'|'cl'|'cm'|'cr'|'bl'|'bm'|'br'|'tli'|'tmi'|'tri'|'cli'|'cmi'|'cri'|'bli'|'bmi'|'bri'|string)?
---@field draw_major Moveable?
---@field major Moveable?

---@class Moveable: Node
---@field role RoleObject
---@field zoom number?
---@operator call:Moveable'''
match_indent = true
times = 1
[[patches]]
[patches.pattern]
target = "engine/moveable.lua"
pattern = "---@param args {T: table, container: Node}"
position = "at"
payload = '''

---@function
---@param X ({T:[number,number,number,number]}|number)?
---@param Y number?
---@param W number?
---@param H number?'''
match_indent = true
times = 1
[[patches]]
[patches.pattern]
target = "engine/moveable.lua"
pattern = "---@param args {major: Moveable, bond: string, offset: table, type: string}"
position = "at"
payload = "---@param args (RoleObject|Moveable)?"
match_indent = true
times = 1

#UI
[[patches]]
[patches.pattern]
target = "engine/ui.lua"
pattern = "--Class"
position = "at"
payload = '''

---@class UIBox: Moveable
---@operator call:UIBox'''
match_indent = true
times = 1
[[patches]]
[patches.pattern]
target = "engine/ui.lua"
pattern = "---@param args {T: table, definition: table, config: table}"
position = "at"
payload = "---@param args UIBox|Moveable"
match_indent = true
times = 1
[[patches]]
[patches.pattern]
target = "engine/ui.lua"
pattern = "--Class"
position = "at"
payload = '''

---@alias UITransform {Root:any,T:any,O:any,B:any,C:any,R:any}
---@class UIElement: Moveable
---@field parent UIElement
---@operator call:UIElement'''
match_indent = true
times = 1
[[patches]]
[patches.pattern]
target = "engine/ui.lua"
pattern = "--Class Methods"
position = "at"
payload = '''

---@function
---@param parent (UIElement|UIBox)
---@param new_UIBox UIBox
---@param new_UIT UITransform
---@param config table'''
match_indent = true
times = 1

#node
[[patches]]
[patches.pattern]
target = "engine/node.lua"
pattern = "---@class Node"
position = "at"
payload = '''

---@alias Transform2D {x:number|0,y:number|0,w:number|1,h:number|1,r:number|0,scale:number|1}
---@alias ChildNodes {d_popup: UIBox,h_popup: UIBox, alert: UIBox,rest...:Node}

---@class Node: Object
---@field T Transform2D
---@field CT Transform2D
---@field VT Transform2D?
---@field DEBUG_VALUE string?
---@field CALCING boolean?
---@field children ChildNodes
---@operator call:Node'''
match_indent = true
times = 1
[[patches]]
[patches.pattern]
target = "engine/node.lua"
pattern = "---@param args {T: table, container: Node}"
position = "at"
payload = '''---@param args {T: [number?,number?,number?,number?,number?,number?]|{x:number?,y:number?,w:number?,h:number?,r:number?,scale:number?}, container: Node}'''
match_indent = true
times = 1

#controller
[[patches]]
[patches.pattern]
target = "engine/controller.lua"
pattern = "---@class Controller"
position = "at"
payload = '''

---@alias Position2D {x:number,y:number}

---@class ControlHandle
---@field handled boolean
---@field target (Card|Node|UIElement)?
---@field time number?
---@field prev_target (Card|Node|UIElement)?
---@field T Position2D?

---@class Controller: Object
---@field clicked ControlHandle
---@field focused ControlHandle
---@field dragging ControlHandle
---@field hovering ControlHandle
---@field released_on ControlHandle
---@field cursor_down ControlHandle
---@field cursor_up ControlHandle
---@field cursor_hover ControlHandle
---@operator call:Controller'''
match_indent = true
times = 1

#object
[[patches]]
[patches.pattern]
target = "engine/object.lua"
pattern = "Object = {}"
position = "at"
payload = '''

---@class Object
---@operator call:Object
Object = {}'''
match_indent = true
times = 1

#event
[[patches]]
[patches.pattern]
target = "engine/event.lua"
pattern = "--Class"
position = "at"
payload = '''

---@class Event:Object
---@operator call:Event'''
match_indent = true
times = 1
[[patches]]
[patches.pattern]
target = "engine/event.lua"
pattern = "--Class Methods"
position = "at"
payload = '''

---@class EventConfig
---@field blockable boolean?
---@field blocking boolean?
---@field trigger ('immediate'|'ease'|'condition'|'after'|'before')?
---@field start_timer boolean?
---@field no_delete boolean?
---@field delay number?
---@field timer ('BACKGROUND'|'REAL'|'REAL_SHADER'|'TOTAL'|'UPTIME')?
---@field ease ('lerp'|'elastic'|'quad')?
---@field ease_to number?
---@field func (fun(progress: number): boolean)?
---@field ref_table table?
---@field ref_value string?
---@field stop_val any?
---@field pause_force boolean?

---@function
---@param config EventConfig'''
match_indent = true
times = 1
[[patches]]
[patches.pattern]
target = "engine/event.lua"
pattern = "--Class"
position = "at"
payload = '''

---@class EventManager:Object
---@operator call:EventManager'''
match_indent = true
times = 1


#Big object patch
[[patches]]
[patches.pattern]
target = "engine/object.lua"
pattern = "Object = {}"
position = "at"
payload = '''Object = {}

---Removes the leading and trailing whitespace characters from a string.
---@param self string
---@return string
function string.trim(self)
    return self:match("^%s*(.-)%s*$")
end

---Converts <code>object</code> into a number using javascript rules (nil is undefined).<br>
---Returns <code>NaN</code> if <code>object</code> could not be converted into a number.
---@param object any
---@return number|Number|nil
_G.numer = function(object)
    if type(object) == "number" then return object end
    if type(object) == "boolean" then return object and 1 or 0 end
    if type(object) == "string" then
        if object == "Infinity" then return Infinity end
        if object == "-Infinity" then return -Infinity end
        if object == "" then return 0 end
    end
    return tonumber(object) or NaN
end

---comment
---@param v any
---@param ... any
---@return Card
_G.safetypecard = function(v,...)
    assert(getmetatable(v)==Card,...)
    return v
end

---comment
---@param str any
---@param ... any
---@return string
_G.safestr = function(str,...)
    assert(type(str) == "string",...)
    return str
end


---comment
---@param tbl any
---@param ... any
---@return table
_G.safetable = function(tbl,...)
    assert(type(tbl) == "table",...)
    return tbl
end

---comment
---@param bl any
---@param ... any
---@return boolean
_G.safebool = function(bl,...)
    assert(type(bl) == "boolean",...)
    return bl
end


_G.dump = function(o)
    if type(o) == 'table' then
        local s = '{ '
        for k,v in pairs(o) do
            if type(k) ~= 'number' then k = '"'..k..'"' end
            s = s .. '['..k..'] = ' .. dump(v) .. ','
        end
        return s .. '} '
    else
        return tostring(o)
    end
end

_G.copy = function(obj, seen)
    if type(obj) ~= 'table' then return obj end
    if seen and seen[obj] then return seen[obj] end
    local s = seen or {}
    local res = setmetatable({}, getmetatable(obj))
    s[obj] = res
    for k, v in pairs(obj) do res[copy(k, s)] = copy(v, s) end
    return res
end

_G.solvepredicate = function(pred)
    if pred == nil then
        pred = function() return true end
    end
    if type(pred) == "boolean" then
        if pred then
            pred = function(v)
                return bool(v)
            end
        else
            pred = function(v)
                return not bool(v)
            end
        end
    end
    if type(pred) == "table" then
        local comparisonType = pred.match or "and"
        if comparisonType == "and" then
            local predicates = pred
            pred = function(...)
                for i,cond in ipairs(predicates) do
                    if not bool(solvepredicate(cond)(...)) then
                        return false
                    end
                end
                return true
            end
        elseif comparisonType == "or" then
            local predicates = pred
            pred = function(...)
                for i,cond in ipairs(predicates) do
                    if bool(solvepredicate(cond)(...)) then
                        return true
                    end
                end
                return false
            end
        end
    end
    if type(pred) ~= "function" then
        local val = pred
        pred = function(v)
            return v == val
        end
    end
    return pred
end

---Returns true if some value inside the list matched the predicate.
---@param tbl table
---@param pred any
---@return boolean
function table.some(tbl,pred)
    pred = solvepredicate(pred)
    for i,v in ipairs(tbl) do
        if pred(v,i,tbl) then
            return true
        end
    end
    return false
end

---Returns true if every value inside the list matched the predicate.
---@param tbl any
---@param pred any
---@return boolean
function table.every(tbl,pred)
   pred = solvepredicate(pred)
   for i,v in ipairs(tbl) do
       if not pred(v,i,tbl) then
           return false
       end
   end
   return true
end

function table.implement(tbl,impl)
    for k,v in pairs(impl) do
        if k == "@override" then goto continue end
        if tbl[k] == nil then
            tbl[k] = v
        elseif type(v) == "table" and type(tbl[k]) == "table" then
            table.implement(tbl[k],v)
        end
        ::continue::
    end
    for k,v in pairs(impl["@override"] or {}) do
        if type(tbl[k]) == "table" and type(v) == "table" then
            table.implement(tbl[k],{["@override"] = v})
        elseif type(tbl[k]) == "function" and v == nil then
            goto continue
        elseif (type(tbl[k]) == "function" or tbl[k] == nil) and type(v) == "function" then
            tbl[k] = v(tbl[k] or function() end)
        else
            tbl[k] = v
        end
        ::continue::
    end
end

function table.get(tbl,...)
    local got = nil
    for i,v in ipairs({...}) do
         if got == nil then
            got = tbl
         end
         got = got[v]
         if got == nil then
            return got
         end
    end
    return got
end

function table.set(tbl,...)
    if type(tbl) ~= "table" then return error("table expected!") end
    local setter = tbl
    local parent = nil
    local args = {...}
    for i,v in ipairs(args) do
        if i == #args then break end
        if setter == nil then 
          parent[v] = {}
          setter = parent[v]
        end
        parent = setter
        setter = setter[v]
    end
    parent[args[#args-1]] = args[#args]
end

function table.at(tbl,index)
    if index == 0 then return nil end
    if index > #tbl then return nil end
    if index < -#tbl then return nil end
    if #tbl == 0 then return nil end
    if #tbl == 1 then return tbl[1] end
    index = index%#tbl
    if index == 0 then index = #tbl end
    return tbl[index]
end

function table.slice(tbl,first,last,step)
    local sliced = {}
    local slice_start = 1
    local slice_end = #tbl
    local slice_step = 1
    local last_is_negative = last and last < 0 or false
    if last_is_negative then
        slice_end = #tbl+last
    elseif last then
        slice_end = last
    end
    local first_is_negative = first and first < 0 or false
    if first_is_negative then
        slice_start = #tbl+first+1
    elseif first then
        slice_start = first
    end
    if slice_start == slice_end then
      sliced[1] = tbl[slice_start]
      return sliced
    end
    local step_is_negative = step and step < 0 or false
    if step_is_negative then
        slice_step = -step
        first_index,last_index = last_index,first_index
    elseif step then
        slice_step = step
    end
    for i=slice_start,slice_end, slice_step do
        sliced[#sliced+1] = tbl[i]
    end
    return sliced
end

---Returns the amount of entries in the list that matched the filter.
---@param tbl table
---@param pred any
---@return integer
function table.count(tbl,pred)
    pred = solvepredicate(pred)
    local count = 0
    for i,v in ipairs(tbl) do
        if pred(v,i,tbl) then
            count = count + 1
        end
    end
    return count
end

---Returns a new list with all the entries of the list that passed the filter.
---@generic H: table
---@param tbl `H`
---@param pred any
---@return H
function table.filter(tbl,pred)
    local rv = {}
    pred = solvepredicate(pred)
    for i,v in ipairs(tbl) do
        if pred(v,i,tbl) then
            table.insert(rv,v)
        end
    end
    return rv
end

---Returns the sum of all the values inside the list.
---@param tbl table
---@param pred any
---@return number
function table.sum(tbl,pred)
    local sum = 0
    pred = solvepredicate(pred)
    for i,v in ipairs(tbl) do
        if pred(v,i,tbl) then
            sum = sum + numer(v)
        end
    end
    return sum
end

---Returns a new list with each value mapped with the mapping function.
---@generic H: table
---@param tbl `H`
---@generic T
---@param func fun(value: any,index: integer,table: H): `T`
---@param pred any
---@return T[]
function table.map(tbl,func,pred)
    local rv = {}
    pred = solvepredicate(pred)
    for i,v in ipairs(tbl) do
        if pred(v,i,tbl) then
            rv[i] = func(v,i,tbl)
        end
    end
    return rv
end

_G.wrapnumber = function(num,first_bound,second_bound)
    local range_length = math.abs(first_bound-second_bound)+1
    local bottom_val = math.min(first_bound,second_bound)
    return ((num-bottom_val)%range_length)+bottom_val
end

_G.combine_return = function(base,more)
   if type(base) ~= "table" and type(more) ~= "table" then return nil end
   if type(base) ~= "table" then return safetable(more) end
   if type(more) ~= "table" then return safetable(base) end
   base = safetable(base)
   more = safetable(more)
   local final_return = base
   if base.extra then
       base.extra = safetable(base.extra)
       final_return.extra = safetable(combine_return(base.extra,more))
   else
       final_return.extra = more
   end
   return final_return
end'''
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = "engine/object.lua"
pattern = "function Object:extend()"
position = "at"
payload = '''

---@alias CardAreaType ("discard"|"deck"|"hand"|"joker"|"play"|"title_2"|"title"|"voucher"|"consumeable"|"shop"|"SELF"|"any"|"none")

---@alias EventAreaContext ("in_blind_select"|"in_round"|"in_round_bonus"|"in_booster_pack"|"in_card_booster_pack"|"in_planet_booster_pack"|"in_tarot_booster_pack"|"in_joker_booster_pack"|"in_spectral_booster_pack")

---@alias EventAreaStage ("in_starting_blind"|"in_small_blind"|"in_big_blind"|"in_boss_blind")

---@alias EventName ("on_update"|"on_blind_select_start"|"on_blind_skip_click"|"on_blind_reroll_click"|"on_blind_click"|"on_blind_select_end_click"|"on_round_start"|"on_discard_click"|"on_discard_card"|"on_discard_end"|"on_discard_draw_card"|"on_discard_draw_end"|"on_play_click"|"on_play_card"|"on_play_end"|"on_score_start"|"on_score_card"|"on_score_lucky"|"on_score_end"|"on_hold_card"|"on_jokers"|"on_jokers_end"|"on_play_discard_card"|"on_play_discard_shatter"|"on_play_discard_end"|"on_play_draw_card"|"on_play_draw_end"|"on_round_end"|"on_round_bonus"|"on_shop_start"|"on_shop_reroll_click"|"on_purchase_click"|"on_create"|"on_add_to_deck"|"on_remove_from_deck"|"on_destroy"|"on_slice"|"on_consumeable"|"on_booster_start"|"on_booster_skip_click"|"on_booster_end"|"on_sell"|"on_shop_end_click"|"on_lose"|"none")

_G.dynamic_get = function(obj,...)
    local args = {...}
    return function()
        return table.get(obj,unpack(args))
    end
end

_G.dynamic_set = function(obj,...)
    local args = {...}
    return function(val)
        table.set(obj,unpack(args),val)
    end
end

---@class ListenerConfig
---@field listener_type ("on_trigger")?
---@field self_type CardTypeName?
---@field self_area CardAreaType?
---@field other_type CardTypeName?
---@field other_area CardAreaType?

---@class EventObject
---@field object Card
---@field applied_abilities table
---@field apply_ability fun(field:AbilityNames)
---@field resign_ability fun(field:AbilityNames)
---@field apply_all_abilities fun()
---@field resign_all_abilities fun()
---@field get_type fun(): CardTypeName?
---@field get_area fun(): CardArea?
---@field get_area_type fun(): CardAreaType?
---@field get fun(field: AbilityNames|"type"|"area"|"area_type"): number
---@field set fun(field: AbilityNames,val:number,force:boolean?)
---@field tug fun(field: AbilityNames,val:number?,operation_func: (fun(a:number,b:number):number)?,force:boolean?)
_G.EventObject = {}

---comment
---@param card Card
---@return EventObject
function EventObject:new(card)
    print("normal")
    local obj = setmetatable({},EventObject)
    obj.object = card
    obj.applied_abilities = {}
    obj.get_type = dynamic_get(card,"config","center","set")
    obj.get_area = dynamic_get(card,"area")
    obj.get_area_type = dynamic_get(card,"area","config","type")
    ---comment
    ---@param field "type"|"area"|"area_type"|AbilityNames
    ---@return unknown|nil
    obj.get = function(field)
        if field == "type" then
            return table.get(card,"config","center","set")
        elseif field == "area" then
            return table.get(card,"area")
        elseif field == "area_type" then
            return table.get(card,"area","config","type")
        else
            return table.get(card,"ability","extra",field)
        end
    end
    ---comment
    ---@param field AbilityNames
    ---@param val number
    ---@param force boolean? allows you to force deterministic values to be changed
    obj.set = function(field,val,force)
        if ({x_chips=1,Xchip_mod=1,x_mult=1,Xmult_mod=1,odds_mult=1})[field] and not val then val = 1 end
        if not val then val = 0 end
        if ({event_id=1,nine_tally=1,steel_tally=1,stone_tally=1,previous_odds=1,extra=1})[field] and not force then error("tried to tug deterministic value of object without force!") end
        if obj.applied_abilities[field] == nil or obj.applied_abilities[field] == true then
            local field_value = (obj.applied_abilities[field] and table.get(card,"ability","extra",field)) or ({x_chips=1,Xchip_mod=1,x_mult=1,Xmult_mod=1,odds_mult=1})[field] or 0
            if field == "interest_cap" then
                G.GAME.interest_cap = (G.GAME.interest_cap - field_value) + val
            elseif field == "interest_amount" then
                G.GAME.interest_amount = (G.GAME.interest_amount - field_value) + val
            elseif field == "debt_size" then
                G.GAME.bankrupt_at = (G.GAME.bankrupt_at + field_value) - val
            elseif field == "h_plays" then
                G.GAME.round_resets.hands = (G.GAME.round_resets.hands - field_value) + val
            elseif field == "d_size" then
                G.GAME.round_resets.discards = (G.GAME.round_resets.discards - field_value) + val
            elseif field == "h_size" then
                G.hand:change_size(((G.hand.config.card_limit - field_value) + val)-G.hand.config.card_limit)
            elseif field == "odds_bonus" then
                local previous_odds = table.get(card,"ability","extra","previous_odds")
                if not previous_odds then
                    table.set(card,"ability","extra","previous_odds",copy(G.GAME.probabilities))
                    previous_odds = table.get(card,"ability","extra","previous_odds") or error("something went very wrong...")
                end
                for k,v in pairs(G.GAME.probabilities) do
                    if not previous_odds[k] then previous_odds[k] = v end
                    local initial_odds = previous_odds[k]
                    local final_odds = (initial_odds+field_value)*(table.get(card,"ability","extra","odds_mult") or 1)
                    local initial_mult_effect = final_odds/initial_odds
                    local changed_odds = (initial_odds+val)*(table.get(card,"ability","extra","odds_mult") or 1)
                    local changed_mult_effect = changed_odds/initial_odds
                    G.GAME.probabilities[k] = (v/initial_mult_effect)*changed_mult_effect
                end
            elseif field == "odds_mult" then
                local previous_odds = table.get(card,"ability","extra","previous_odds")
                if not previous_odds then
                    table.set(card,"ability","extra","previous_odds",copy(G.GAME.probabilities))
                    previous_odds = table.get(card,"ability","extra","previous_odds") or error("something went very wrong...")
                end
                for k,v in pairs(G.GAME.probabilities) do
                    if not previous_odds[k] then previous_odds[k] = v end
                    local initial_odds = previous_odds[k]
                    local final_odds = (initial_odds+(table.get(card,"ability","extra","odds_bonus") or 0))*field_value
                    local initial_mult_effect = final_odds/initial_odds
                    local changed_odds = (initial_odds+(table.get(card,"ability","extra","odds_bonus") or 0))*val
                    local changed_mult_effect = changed_odds/initial_odds
                    G.GAME.probabilities[k] = (v/initial_mult_effect)*changed_mult_effect
                end
            elseif field == "free_rerolls" then
                G.GAME.current_round.free_rerolls = (G.GAME.current_round.free_rerolls - field_value) + val
                calculate_reroll_cost(true)
            end
        end
        table.set(card,"ability","extra",field,val)
    end
    ---comment
    ---@param field AbilityNames
    ---@param val number?
    ---@param operation_func (fun(a:number,b:number): number)?
    ---@param force boolean? allows you to force deterministic values to be changed
    obj.tug = function(field,val,operation_func,force)
        if operation_func == nil then operation_func = function(a,b) return a + b end end
        local field_value = table.get(card,"ability","extra",field) or ({x_chips=1,Xchip_mod=1,x_mult=1,Xmult_mod=1,odds_mult=1})[field] or 0
        local new_value = operation_func(field_value,val or 0)
        obj.set(field,new_value,force)
    end
    obj.apply_ability = function(field)
        if ({event_id=1,nine_tally=1,steel_tally=1,stone_tally=1,previous_odds=1,extra=1})[field] then return end
        if obj.applied_abilities[field] == true then return end
        obj.applied_abilities[field] = nil
        obj.tug(field)
        obj.applied_abilities[field] = true
    end
    obj.resign_ability = function(field)
        if ({event_id=1,nine_tally=1,steel_tally=1,stone_tally=1,previous_odds=1,extra=1})[field] then return end
        if obj.applied_abilities[field] == false then return end
        obj.set(field,({x_chips=1,Xchip_mod=1,x_mult=1,Xmult_mod=1,odds_mult=1})[field] or 0)
        obj.applied_abilities[field] = false
    end
    obj.apply_all_abilities = function()
        for field,_ in pairs(AbilityNames) do
            obj.apply_ability(field)
        end
    end
    obj.resign_all_abilities = function()
        for field,_ in pairs(AbilityNames) do
            obj.resign_ability(field)
        end
    end
    return obj
end

---@class GameEventContext
---@field no_blueprint boolean
---@field blueprint number|nil
---@field blueprint_card Card
---@field open_booster boolean
---@field buying_card boolean
---@field selling_self boolean
---@field selling_card boolean
---@field reroll_shop boolean
---@field ending_shop boolean
---@field skip_blind boolean
---@field skipping_booster boolean
---@field playing_card_added boolean
---@field cards Card[]
---@field first_hand_drawn boolean
---@field setting_blind boolean
---@field blind {boss: boolean}
---@field destroying_card boolean
---@field full_hand Card[]
---@field cards_destroyed boolean
---@field glass_shattered boolean
---@field remove_playing_cards boolean
---@field removed Card[]
---@field using_consumeable boolean
---@field consumeable Card
---@field debuffed_hand boolean
---@field pre_discard boolean
---@field hook boolean
---@field discard boolean
---@field other_card Card
---@field end_of_round boolean
---@field individual boolean
---@field repetition boolean
---@field cardarea CardArea
---@field card_effects unknown[]
---@field game_over boolean
---@field scoring_hand Card[]
---@field other_joker Card
---@field before boolean
---@field poker_hands unknown
---@field scoring_name string
---@field after boolean
---@field joker_main boolean

---@class EventContext
---@field SELF Object
---@field CONTEXT GameEventContext
---@field self EventObject
---@field other EventObject

---comment
---@param eventName EventName
---@param config ListenerConfig?
---@param callback fun(context: EventContext): any
---@return self
function Object:addEventListener(eventName,config,callback)
    config = config or {}
    if not config.self_type then config.self_type = "any" end
    if not config.self_area then config.self_area = "any" end
    if not config.other_type then config.other_type = "SELF" end
    if not config.other_area then config.other_area = "SELF" end
    local function refersToSelf(_config)
        return _config.other_type == "SELF" and _config.other_area == "SELF"
    end
    local function refersToCard(_config)
        return (_config.other_type == "Default" or _config.other_type == "Enhanced" or _config.other_type == "any")
    end
    local function referenceInPlay(_config)
        return (_config.other_area == "play" or _config.other_area == "any")
    end
    local function referenceInDiscard(_config)
        return (_config.other_area == "discard" or _config.other_area == "any")
    end
    local function build_function(cond_func,combine_func)
        if combine_func == nil then combine_func = combine_return end
        return function(old_func)
            return function(_self,card,context)
                local first = nil
                local second = nil
                first = old_func(_self,card,context)
                local this_card = EventObject:new(card)
                local other_card = nil
                if refersToSelf(config) then
                   other_card = EventObject:new(card)
                elseif refersToCard(config) then
                    other_card = EventObject:new(context.other_card)
                else
                    error("Invalid state!")
                end
                if solvepredicate(cond_func)(context,this_card,other_card) then
                    second = callback({
                        SELF = _self,
                        CONTEXT = context,
                        self = this_card,
                        other = other_card
                    })
                end
                return combine_func(first,second)
            end
        end
    end
   table.implement(self,{
    ["@override"] = {
        calculate = ({
            on_jokers = refersToSelf(config) and build_function(function(context) return
                context.cardarea == G.jokers and context.joker_main
            end),
            on_score_card = refersToCard(config) and referenceInPlay(config) and build_function(function(context,_self,other) return 
                other.object and other.get_area() == G.play and context.individual
            end),
            on_round_end = refersToSelf(config) and build_function(function(context) return
                context.end_of_round and not context.individual and not context.repetition
            end),
            on_jokers_end = refersToSelf(config) and build_function(function(context) return 
                context.after and not context.individual and not context.repetition and context.cardarea == G.jokers
            end),
            on_discard_card = refersToCard(config) and referenceInDiscard(config) and build_function(function(context) return 
                context.discard and not context.pre_discard
            end),
            on_discard_click = refersToCard(config) and referenceInDiscard(config) and build_function(function(context) return 
                context.pre_discard and not context.discard
            end),
            on_play_click = refersToSelf(config) and build_function(function(context) return 
                context.before and not context.individual and not context.repetition and context.cardarea == G.jokers
            end),
        })[eventName] or nil,
        calc_dollar_bonus = ({
            on_round_bonus = refersToSelf(config) and build_function(nil,function(a,b) return 
                (a or 0)+(b or 0)
            end),
        })[eventName] or nil,
        add_to_deck = ({
            on_add_to_deck = refersToSelf(config) and build_function(nil,function()end),
        })[eventName] or nil,
        remove_from_deck = ({
            on_remove_from_deck = refersToSelf(config) and build_function(nil,function()end)
        })[eventName] or nil,
    }
   })
   return self
end

function Object:extend()'''
match_indent = true
times = 1
[[patches]]
[patches.pattern]
target = "engine/object.lua"
pattern = '''function Object:__call(...)
  local obj = setmetatable({}, self)
  obj:init(...)
  return obj
end'''
position = "after"
payload = '''


---NaN literal
---@type number
_G.NaN = 0/0

---Infinity literal
---@type number
_G.Infinity = 1/0

---Returns true if <code>object</code> cannot be operated with a number or if <code>object</code> is <code>NaN</code>.
---@param object any
---@return boolean
_G.isNaN = function(object)
   if getmetatable(object) == Number then
      return object.value ~= object.value
   else
      return object ~= object
   end
end

---Returns true if <code>object</code> cannot be operated with a number or if <code>object</code> is <code>WaN</code>.
---@param object any
---@return boolean
_G.isWaN = function(object)
   return getmetatable(object) == Number and object.value == WaN.value or false
end

---@type fun(e: any, base:any): number?
local original_tonumber = tonumber
tonumber = function(e,base)
   local rv = original_tonumber(e,base)
   if rv == nil and getmetatable(e) == Number then
      if isWaN(e) then
         return WaN
      else
         return e.value
      end
   elseif rv ~= nil then
      return rv
   else
      return nil
   end
end

local original_type = type
type = function(obj)
   local rv = original_type(obj)
   if rv == "table" and getmetatable(obj) == Number then
      return "number"
   else
      return rv
   end
end

---@class Number
---@field value number|"-wan"
_G.Number = {}
Number.__index = Number

---A wrapper class for all numbers to allow for special values (like WaN) to exist
---@param other any
---@return Number?
function Number:new(other)
   if not other then
      return nil
   elseif isWaN(other) then
      return WaN
   elseif getmetatable(other) == Number then
      local instance = Number:new(other.value)
      return instance
   elseif other == "-wan" then
      local instance = setmetatable({},Number)
      instance.value = "-wan"
      return instance
   else
      if type(other) ~= "number" then return nil end
      local instance = setmetatable({},Number)
      instance.value = other
      return instance
   end
end

function Number:__unm()
   if isWaN(self) then return WaN end
   return Number:new(-tonumber(self))
end

function Number:__mod(other)
   if isWaN(self) then return WaN end
   if isWaN(other) then return WaN end
   return Number:new(tonumber(self) % tonumber(other))
end

function Number:__pow(other)
   if isWaN(self) then return WaN end
   if isWaN(other) then return WaN end
   return Number:new(tonumber(self) ^ tonumber(other))
end

function Number:__add(other)
   if isWaN(self) then return WaN end
   if isWaN(other) then return WaN end
   return Number:new(tonumber(self) + tonumber(other))
end

function Number:__sub(other)
   if isWaN(self) then return WaN end
   if isWaN(other) then return WaN end
   return Number:new(tonumber(self) - tonumber(other))
end

function Number:__mul(other)
   if isWaN(self) then return WaN end
   if isWaN(other) then return WaN end
   return Number:new(tonumber(self) * tonumber(other))
end

function Number:__div(other)
   if isWaN(self) then return WaN end
   if isWaN(other) then return WaN end
   return Number:new(tonumber(self) / tonumber(other))
end

function Number:__tostring()
   if isWaN(self) then return WaN.value end
   return tostring(tonumber(self))
end

function Number.__concat(a,b)
   return tostring(a) .. tostring(b)
end

function Number:__eq(other)
   if isWaN(self) then return not isNaN(other) end
   if isWaN(other) then return not isNaN(self) end
   return tonumber(self) == tonumber(other)
end

function Number:__lt(other)
   if isWaN(self) then return not isNaN(other) end
   if isWaN(other) then return not isNaN(self) end
   return tonumber(self) < tonumber(other)
end

function Number:__le(other)
   if isWaN(self) then return not isNaN(other) end
   if isWaN(other) then return not isNaN(self) end
   return tonumber(self) <= tonumber(other)
end

---Wild number literal
---@type Number
_G.WaN = Number:new("-wan") or error("Mistakes have been made...")

---Evaluates falsy objects according to javascript rules.
---@param any any
---@return boolean
_G.bool = function(any)
    if not any or (any == Number:new(0) and not isWaN(any)) or (type(any)=="number" and isNaN(any)) or any == "" then return false end
    return true
end
'''
match_indent = true
times = 1

#card
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''Card = Moveable:extend()'''
position = "before"
payload = '''
---@alias AbilityNames ("event_id"|"chips"|"h_chips"|"t_chips"|"chip_mod"|"x_chips"|"Xchip_mod"|"mult"|"h_mult"|"t_mult"|"mult_mod"|"x_mult"|"h_x_mult"|"Xmult_mod"|"dollars"|"h_dollars"|"p_dollars"|"interest_cap"|"interest_gain"|"interest_amount"|"debt_size"|"h_plays"|"d_size"|"h_size"|"odds_bonus"|"odds_mult"|"free_rerolls"|"extra"|"discards_since_create"|"hands_played_since_create"|"consecutive_without_face_cards"|"consecutive_without_most_played"|"nine_tally"|"steel_tally"|"stone_tally"|"previous_odds")

_G.AbilityNames = {
    ["event_id"] = 0,
    ["chips"] = 0,
    ["h_chips"] = 0,
    ["t_chips"] = 0,
    ["chip_mod"] = 0,
    ["x_chips"] = 1,
    ["Xchip_mod"] = 1,
    ["mult"] = 0,
    ["h_mult"] = 0,
    ["t_mult"] = 0,
    ["mult_mod"] = 0,
    ["x_mult"] = 1,
    ["h_x_mult"] = 1,
    ["Xmult_mod"] = 1,
    ["dollars"] = 0,
    ["h_dollars"] = 0,
    ["p_dollars"] = 0,
    ["interest_cap"] = 0,
    ["interest_gain"] = 0,
    ["interest_amount"] = 0,
    ["debt_size"] = 0,
    ["h_plays"] = 0,
    ["d_size"] = 0,
    ["h_size"] = 0,
    ["odds_bonus"] = 0,
    ["odds_mult"] = 0,
    ["free_rerolls"] = 0,
    ["extra"] = {},
    ["discards_since_create"] = 0,
    ["hands_played_since_create"] = 0,
    ["consecutive_without_face_cards"] = 0,
    ["consecutive_without_most_played"] = 0,
    ["nine_tally"] = 0,
    ["steel_tally"] = 0,
    ["stone_tally"] = 0,
    ["previous_odds"] = {},
}

---@alias CardTypeName ("Default"|"Enhanced"|"Joker"|"Edition"|"Tarot"|"Planet"|"Voucher"|"Spectral"|"Booster"|"Back"|"None"|"SELF"|"any")
---@alias CardSuitName ("Hearts"|"Clubs"|"Diamonds"|"Spades")
---@alias CardRankName ("2"|"3"|"4"|"5"|"6"|"7"|"8"|"9"|"10"|"Jack"|"Queen"|"King"|"Ace")
---@alias CardWholeName ("2 of Hearts"|"3 of Hearts"|"4 of Hearts"|"5 of Hearts"|"6 of Hearts"|"7 of Hearts"|"8 of Hearts"|"9 of Hearts"|"10 of Hearts"|"Jack of Hearts"|"Queen of Hearts"|"King of Hearts"|"Ace of Hearts"|"2 of Clubs"|"3 of Clubs"|"4 of Clubs"|"5 of Clubs"|"6 of Clubs"|"7 of Clubs"|"8 of Clubs"|"9 of Clubs"|"10 of Clubs"|"Jack of Clubs"|"Queen of Clubs"|"King of Clubs"|"Ace of Clubs"|"2 of Diamonds"|"3 of Diamonds"|"4 of Diamonds"|"5 of Diamonds"|"6 of Diamonds"|"7 of Diamonds"|"8 of Diamonds"|"9 of Diamonds"|"10 of Diamonds"|"Jack of Diamonds"|"Queen of Diamonds"|"King of Diamonds"|"Ace of Diamonds"|"2 of Spades"|"3 of Spades"|"4 of Spades"|"5 of Spades"|"6 of Spades"|"7 of Spades"|"8 of Spades"|"9 of Spades"|"10 of Spades"|"Jack of Spades"|"Queen of Spades"|"King of Spades"|"Ace of Spades")
---@alias CardEffectName ("Base"|"Mult"|"Suit Mult"|"Type Mult"|"Hand Size Mult"|"Hand card double"|"Credit"|"Discard Chips"|"No Discard Mult"|"Stone card hands"|"1 in 10 mult"|"Spawn Tarot"|"Random Mult"|"Socialized Mult"|"Bonus Rerolls"|"Card Mult"|"Steel Card Buff"|"Scary Face Cards"|"Joker Mult"|"Discard dollars"|"Low Card double"|"All face cards"|"Even Card Buff"|"Odd Card Buff"|"Ace Buff"|"Face Card dollar Chance"|"Hand played mult"|"Upgrade Hand chance"|"Hand Size"|"Discard Size"|"Stone Card Buff"|"Bonus dollars"|"dollars for Gold cards"|"Prevent Death"|"Shop size"|"Face card double"|"Set Mult"|"Hand Size, Plays"|"Glass Card"|"Copycat"|"X1.5 Mult club 7"|"Jack Discard Effect"|"X1.5 Mult"|"X2 Mult"|"X3 Mult"|"Tarot Buff"|"Disable Blind Effect"|"Enhance"|"Round Bonus"|"Dollar Doubler"|"Card Removal"|"Card Conversion"|"Joker Payout"|"Suit Conversion"|"Hand Upgrade"|"Unlocker"|"Bonus Card"|"Mult Card"|"Wild Card"|"Steel Card"|"Stone Card"|"Gold Card"|"Lucky Card"|"")
---@alias CardNameName ("Default Base"|"Joker"|"Greedy Joker"|"Lusty Joker"|"Wrathful Joker"|"Gluttonous Joker"|"Jolly Joker"|"Zany Joker"|"Mad Joker"|"Crazy Joker"|"Droll Joker"|"Sly Joker"|"Wily Joker"|"Clever Joker"|"Devious Joker"|"Crafty Joker"|"Half Joker"|"Joker Stencil"|"Four Fingers"|"Mime"|"Credit Card"|"Ceremonial Dagger"|"Banner"|"Mystic Summit"|"Marble Joker"|"Loyalty Card"|"8 Ball"|"Misprint"|"Dusk"|"Raised Fist"|"Chaos the Clown"|"Fibonacci"|"Steel Joker"|"Scary Face"|"Abstract Joker"|"Delayed Gratification"|"Hack"|"Pareidolia"|"Gros Michel"|"Even Steven"|"Odd Todd"|"Scholar"|"Business Card"|"Supernova"|"Ride the Bus"|"Space Joker"|'Egg'|'Burglar'|'Blackboard'|'Runner'|'Ice Cream'|'DNA'|'Splash'|'Blue Joker'|'Sixth Sense'|'Constellation'|'Hiker'|'Faceless Joker'|'Green Joker'|'Superposition'|'To Do List'|"Cavendish"|"Card Sharp"|"Red Card"|"Madness"|"Square Joker"|"Seance"|"Riff-raff"|"Vampire"|"Shortcut"|"Hologram"|"Vagabond"|"Baron"|"Cloud 9"|"Rocket"|"Obelisk"|"Midas Mask"|"Luchador"|"Photograph"|"Gift Card"|"Turtle Bean"|"Erosion"|"Reserved Parking"|"Mail-In Rebate"|"To the Moon"|"Hallucination"|"Fortune Teller"|"Juggler"|"Drunkard"|"Stone Joker"|"Golden Joker"|"Lucky Cat"|"Baseball Card"|"Bull"|"Diet Cola"|"Trading Card"|"Flash Card"|"Popcorn"|"Spare Trousers"|"Ancient Joker"|"Ramen"|"Walkie Talkie"|"Seltzer"|"Castle"|"Smiley Face"|"Campfire"|"Golden Ticket"|"Mr. Bones"|"Acrobat"|"Sock and Buskin"|"Swashbuckler"|"Troubadour"|"Certificate"|"Smeared Joker"|"Throwback"|"Hanging Chad"|"Rough Gem"|"Bloodstone"|"Arrowhead"|"Onyx Agate"|"Glass Joker"|"Showman"|"Flower Pot"|"Blueprint"|"Wee Joker"|"Merry Andy"|"Oops! All 6s"|"The Idol"|"Seeing Double"|"Matador"|"Hit the Road"|"The Duo"|"The Trio"|"The Family"|"The Order"|"The Tribe"|"Stuntman"|"Invisible Joker"|"Brainstorm"|"Satellite"|"Shoot the Moon"|"Driver's License"|"Cartomancer"|"Astronomer"|"Burnt Joker"|"Bootstraps"|"Caino"|"Triboulet"|"Yorick"|"Chicot"|"Perkeo"|"The Fool"|"The Magician"|"The High Priestess"|"The Empress"|"The Emperor"|"The Hierophant"|"The Lovers"|"The Chariot"|"Justice"|"The Hermit"|"The Wheel of Fortune"|"Strength"|"The Hanged Man"|"Death"|"Temperance"|"The Devil"|"The Tower"|"The Star"|"The Moon"|"The Sun"|"Judgement"|"The World"|"Mercury"|"Venus"|"Earth"|"Mars"|"Jupiter"|"Saturn"|"Uranus"|"Neptune"|"Pluto"|"Planet X"|"Ceres"|"Eris"|"Familiar"|"Grim"|"Incantation"|"Talisman"|"Aura"|"Wraith"|"Sigil"|"Ouija"|"Ectoplasm"|"Immolate"|"Ankh"|"Deja Vu"|"Hex"|"Trance"|"Medium"|"Cryptid"|"The Soul"|"Black Hole"|"Overstock"|"Clearance Sale"|"Hone"|"Reroll Surplus"|"Crystal Ball"|"Telescope"|"Grabber"|"Wasteful"|"Tarot Merchant"|"Planet Merchant"|"Seed Money"|"Blank"|"Magic Trick"|"Hieroglyph"|"Director's Cut"|"Paint Brush"|"Overstock Plus"|"Liquidation"|"Glow Up"|"Reroll Glut"|"Omen Globe"|"Observatory"|"Nacho Tong"|"Recyclomancy"|"Tarot Tycoon"|"Planet Tycoon"|"Money Tree"|"Antimatter"|"Illusion"|"Petroglyph"|"Retcon"|"Palette"|"Red Deck"|"Blue Deck"|"Yellow Deck"|"Green Deck"|"Black Deck"|"Magic Deck"|"Nebula Deck"|"Ghost Deck"|"Abandoned Deck"|"Checkered Deck"|"Zodiac Deck"|"Painted Deck"|"Anaglyph Deck"|"Plasma Deck"|"Erratic Deck"|"Challenge Deck"|"Bonus"|"Mult"|"Wild Card"|"Glass Card"|"Steel Card"|"Stone Card"|"Gold Card"|"Lucky Card"|"Base"|"Foil"|"Holographic"|"Polychrome"|"Negative"|"Arcana Pack"|"Jumbo Arcana Pack"|"Mega Arcana Pack"|"Celestial Pack"|"Jumbo Celestial Pack"|"Mega Celestial Pack"|"Spectral Pack"|"Jumbo Spectral Pack"|"Mega Spectral Pack"|"Standard Pack"|"Jumbo Standard Pack"|"Mega Standard Pack"|"Buffoon Pack"|"Jumbo Buffoon Pack"|"Mega Buffoon Pack"|string)
---@alias CardEnhancementName ("m_bonus"|"m_mult"|"m_wild"|"m_glass"|"m_steel"|"m_stone"|"m_gold"|"m_lucky")
---@alias CardSealName ("Gold"|"Red"|"Blue"|"Purple")
---@alias CardBoosterKindName ("Arcana"|"Spectral"|"Celestial"|"Standard"|"Buffoon")
---@alias PokerHandName ("High Card"|"Pair"|"Two Pair"|"Three of a Kind"|"Straight"|"Flush"|"Four of a Kind"|"Full House"|"Straight Flush"|"Five of a Kind"|"Flush House"|"Flush Five")
---@alias VoucherName ("v_overstock_norm"|"v_clearance_sale"|"v_hone"|"v_reroll_surplus"|"v_crystal_ball"|"v_telescope"|"v_grabber"|"v_wasteful"|"v_tarot_merchant"|"v_planet_merchant"|"v_seed_money"|"v_blank"|"v_magic_trick"|"v_hieroglyph"|"v_directors_cut"|"v_paint_brush"|"v_overstock_plus"|"v_liquidation"|"v_glow_up"|"v_reroll_glut"|"v_omen_globe"|"v_observatory"|"v_nacho_tong"|"v_recyclomancy"|"v_tarot_tycoon"|"v_planet_tycoon"|"v_money_tree"|"v_antimatter"|"v_illusion"|"v_petroglyph"|"v_retcon"|"v_palette")
---@alias ConsumeableName ("c_fool"|"c_magician"|"c_high_priestess"|"c_empress"|"c_emperor"|"c_heirophant"|"c_lovers"|"c_chariot"|"c_justice"|"c_hermit"|"c_wheel_of_fortune"|"c_strength"|"c_hanged_man"|"c_death"|"c_temperance"|"c_devil"|"c_tower"|"c_star"|"c_moon"|"c_sun"|"c_judgement"|"c_world"|"c_mercury"|"c_venus"|"c_earth"|"c_mars"|"c_jupiter"|"c_saturn"|"c_uranus"|"c_neptune"|"c_pluto"|"c_planet_x"|"c_ceres"|"c_eris"|"c_familiar"|"c_grim"|"c_incantation"|"c_talisman"|"c_aura"|"c_wraith"|"c_sigil"|"c_ouija"|"c_ectoplasm"|"c_immolate"|"c_ankh"|"c_deja_vu"|"c_hex"|"c_trance"|"c_medium"|"c_cryptid"|"c_soul"|"c_black_hole")
---@alias TagEffectTimingName ('store_joker_create'|'store_joker_modify'|'eval'|'voucher_add'|'new_blind_choice'|'immediate'|'shop_final_pass'|'tag_add'|'round_start_bonus'|'shop_start')

---@class CardConfigCenter: Sprite
---@field key string
---@field name string
---@field effect string
---@field alerted boolean
---@field order number
---@field set CardObjectType
---@field atlas string
---@field consumeable CardConfigCenter
---@field demo boolean
---@field unlocked boolean
---@field discovered boolean
---@field pos {x:number,y:number}
---@field pixel_size {w:number,h:number}
---@field display_size {w:number,h:number}
---@field set_sprites (fun(self:self,card:Card,front:unknown))?
---@field soul_pos {x:number,y:number}
---@field eternal_compat boolean
---@field perishable_compat boolean
---@field no_suit boolean
---@field no_rank boolean
---@field replace_base_card boolean
---@field rarity number
---@field undiscovered CardConfigCenter
---@field hc_atlas string
---@field lc_atlas string
---@field no_overlay boolean

---@class CardConfig
---@field card P_CARDS_VALUE|Card
---@field center CardConfigCenter
---@field card_key string?
---@field center_key string?
---@field h_popup UIElement?
---@field h_popup_config UIElement?

---comment
---@class Card: Moveable
---@field config CardConfig
---@operator call:Card'''
match_indent = true
times = 1
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''function Card:set_base(card, initial)'''
position = "before"
payload = '''---comment
---@param card Card
---@param initial boolean'''
match_indent = true
times = 1
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''function Card:get_chip_x_mult(context)'''
position = "before"
payload = '''---comment
---@param context GameEventContext
---@return unknown, unknown|nil'''
match_indent = true
times = 1
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''function Card:get_end_of_round_effect(context)'''
position = "before"
payload = '''---comment
---@param context GameEventContext
---@return unknown, unknown|nil'''
match_indent = true
times = 1
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''function Card:can_sell_card(context)'''
position = "before"
payload = '''---comment
---@param context GameEventContext
---@return unknown, unknown|nil'''
match_indent = true
times = 1
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''function Card:calculate_seal(context)'''
position = "before"
payload = '''---comment
---@param context GameEventContext
---@return unknown, unknown|nil'''
match_indent = true
times = 1
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''function Card:calculate_joker(context)'''
position = "before"
payload = '''---comment
---@param context GameEventContext
---@return unknown, unknown|nil'''
match_indent = true
times = 1

#game
[[patches]]
[patches.pattern]
target = "game.lua"
pattern = "    self.P_CARDS = {"
position = "before"
payload = '''
    ---@alias P_CARDS_VALUE {name:string,value:"2"|"3"|"4"|"5"|"6"|"7"|"8"|"9"|"10"|"Jack"|"Queen"|"King"|"Ace",suit:"Hearts"|"Clubs"|"Diamonds"|"Spades",pos:{x:number,y:number}}
    ---@alias P_CARDS_TYPE {[string]:P_CARDS_VALUE}
    ---@type P_CARDS_TYPE
'''
match_indent = true
times = 1
[[patches]]
[patches.pattern]
target = "game.lua"
pattern = "    self.P_CENTERS = {"
position = "before"
payload = '''
    ---@alias P_CENTERS_VALUE {max:number,freq:number,line:string,label:string,available:boolean,kind:CardBoosterKindName,weight:number,order:number,unlocked:boolean,start_alerted:boolean,discovered:boolean,blueprint_compat:boolean,perishable_compat:boolean,eternal_compat:boolean,rarity:1|2|3|4,cost:number,name:CardNameName,pos:{x:number,y:number},set:CardTypeName,effect:CardEffectName,cost_mult:number,config:EventQuery}
    ---@alias P_CENTERS_TYPE {[string]:P_CENTERS_VALUE}
    ---@type P_CENTERS_TYPE
'''
match_indent = true
times = 1