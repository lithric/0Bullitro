[manifest]
version = "1.0.0"
dump_lua = true
priority = 0


[[patches]]
[patches.pattern]
target = "engine/object.lua"
pattern = "--||--"
position = "before"
payload = '''
_G.solvepredicate = function(pred)
    if nil == pred then return function() return true end end
    if true == pred then return function(v) return not not v end end
    if false == pred then return function(v) return not v end end
    local pred_type = type(pred)
    if pred_type == "function" then return pred end
    if pred_type == "table" and pred.match == "and" then return function(...) for _,cond in ipairs(pred) do if not solvepredicate(cond)(...) then return false end end return true end end
    if pred_type == "table" and pred.match == "or" then return function(...) for _,cond in ipairs(pred) do if solvepredicate(cond)(...) then return true end end return false end end
    return function(v) return v == pred end
end

---Returns true if some value inside the list matched the predicate.
---@param tbl table
---@param pred any
---@return boolean
function table.some(tbl,pred)
    pred = solvepredicate(pred)
    for i,v in ipairs(tbl) do
        if pred(v,i,tbl) then
            return true
        end
    end
    return false
end

---Returns true if some value inside the list matched the predicate.
---@param tbl table
---@param pred any
---@return boolean
function table.ksome(tbl,pred)
    pred = solvepredicate(pred)
    for k,v in pairs(tbl) do
        if pred(v,k,tbl) then
            return true
        end
    end
    return false
end

---Returns true if every value inside the list matched the predicate.
---@param tbl any
---@param pred any
---@return boolean
function table.every(tbl,pred)
   pred = solvepredicate(pred)
   for i,v in ipairs(tbl) do
       if not pred(v,i,tbl) then
           return false
       end
   end
   return true
end

---Returns true if every value inside the list matched the predicate.
---@param tbl any
---@param pred any
---@return boolean
function table.kevery(tbl,pred)
    pred = solvepredicate(pred)
    for k,v in pairs(tbl) do
        if not pred(v,k,tbl) then
            return false
        end
    end
    return true
 end

function table.implement(tbl,impl)
    for k,v in pairs(impl) do
        if k == "@override" then goto continue end
        if tbl[k] == nil then
            tbl[k] = v
        elseif type(v) == "table" and type(tbl[k]) == "table" then
            table.implement(tbl[k],v)
        end
        ::continue::
    end
    for k,v in pairs(impl["@override"] or {}) do
        if type(tbl[k]) == "table" and type(v) == "table" then
            table.implement(tbl[k],{["@override"] = v})
        elseif type(tbl[k]) == "function" and v == nil then
            goto continue
        elseif (type(tbl[k]) == "function" or tbl[k] == nil) and type(v) == "function" then
            tbl[k] = v(tbl[k] or function() end)
        else
            tbl[k] = v
        end
        ::continue::
    end
end

function table.get(tbl,...)
    local got = nil
    for i,v in ipairs({...}) do
         if got == nil then
            got = tbl
         end
         got = got[v]
         if got == nil then
            return got
         end
    end
    return got
end

function table.set(tbl,...)
    if type(tbl) ~= "table" then return error("table expected!") end
    local setter = tbl
    local parent = nil
    local args = {...}
    for i,v in ipairs(args) do
        if i == #args then break end
        if setter == nil then
          parent[v] = {}
          setter = parent and parent[v]
        end
        parent = setter
        setter = setter[v]
    end
    parent[args[#args-1]] = args[#args]
end

function table.at(tbl,index)
    if type(index) ~= "number" then return tbl[index] end
    if index == 0 then return nil end
    if index > #tbl then return nil end
    if index < -#tbl then return nil end
    if #tbl == 0 then return nil end
    if #tbl == 1 then return tbl[1] end
    index = index%#tbl
    if index == 0 then index = #tbl end
    return tbl[index]
end

function table.slice(tbl,first,last,step)
    local sliced = {}
    local slice_start = 1
    local slice_end = #tbl
    local slice_step = 1
    local last_is_negative = last and last < 0 or false
    if last_is_negative then
        slice_end = #tbl+last
    elseif last then
        slice_end = last
    end
    local first_is_negative = first and first < 0 or false
    if first_is_negative then
        slice_start = #tbl+first+1
    elseif first then
        slice_start = first
    end
    if slice_start == slice_end then
      sliced[1] = tbl[slice_start]
      return sliced
    end
    local step_is_negative = step and step < 0 or false
    if step_is_negative then
        slice_step = -step
        slice_start,slice_end = slice_end,slice_start
    elseif step then
        slice_step = step
    end
    for i=slice_start,slice_end, slice_step do
        sliced[#sliced+1] = tbl[i]
    end
    return sliced
end

---Returns the amount of entries in the list that matched the filter.
---@param tbl table
---@param pred any
---@return integer
function table.count(tbl,pred)
    pred = solvepredicate(pred)
    local count = 0
    for i,v in ipairs(tbl) do
        if pred(v,i,tbl) then
            count = count + 1
        end
    end
    return count
end

---Returns the amount of entries in the list that matched the filter.
---@param tbl table
---@param pred any
---@return integer
function table.kcount(tbl,pred)
    pred = solvepredicate(pred)
    local count = 0
    for k,v in pairs(tbl) do
        if pred(v,k,tbl) then
            count = count + 1
        end
    end
    return count
end

---Returns a new list with all the entries of the list that passed the filter.
---@generic H: table
---@param tbl `H`
---@param pred any
---@return H
function table.filter(tbl,pred)
    local rv = {}
    pred = solvepredicate(pred)
    for i,v in ipairs(tbl) do
        if pred(v,i,tbl) then
            table.insert(rv,v)
        end
    end
    return rv
end

---Returns a new list with all the entries of the list that passed the filter.
---@generic H: table
---@param tbl `H`
---@param pred any
---@return H
function table.kfilter(tbl,pred)
    local rv = {}
    pred = solvepredicate(pred)
    for k,v in pairs(tbl) do
        if pred(v,k,tbl) then
            table.insert(rv,v)
        end
    end
    return rv
end

---Returns the sum of all the values inside the list.
---@param tbl table
---@param pred any
---@return number
function table.sum(tbl,pred)
    local sum = 0
    pred = solvepredicate(pred)
    for i,v in ipairs(tbl) do
        if pred(v,i,tbl) then
            sum = sum + numer(v)
        end
    end
    return sum
end

---Returns the sum of all the values inside the list.
---@param tbl table
---@param pred any
---@return number
function table.ksum(tbl,pred)
    local sum = 0
    pred = solvepredicate(pred)
    for k,v in pairs(tbl) do
        if pred(v,k,tbl) then
            sum = sum + numer(v)
        end
    end
    return sum
end

---Returns a new list with each value mapped with the mapping function.
---@generic H: table
---@param tbl `H`
---@generic T
---@param func fun(value: any,index: integer,table: H): `T`
---@return T[]
function table.map(tbl,func)
    local rv = {}
    for i,v in ipairs(tbl) do
        rv[#rv+1] = func(v,i,tbl)
    end
    return rv
end

---Returns a new list with each value mapped with the mapping function.
---@generic H: table
---@param tbl `H`
---@generic T
---@param func fun(value: any,index: integer,table: H): `T`
---@return T[]
function table.kmap(tbl,func)
    local rv = {}
    for k,v in pairs(tbl) do
        rv[k] = func(v,k,tbl)
    end
    return rv
end

function table.flat(tbl,depth)
    if not depth then depth = 1 end
    if depth == 0 then return tbl end
    local rv = {}
    for _,v in ipairs(tbl) do
        if type(v) == "table" then
            for _,w in ipairs(table.flat(v,depth-1)) do
                rv[#rv+1] = w
            end
        else
            rv[#rv+1] = v
        end
    end
    return rv
end

function table.flatmap(tbl,func)
    local rv = {}
    for i,v in ipairs(tbl) do
        local val = func(v,i,tbl)
        if type(val) == "table" then
            for _,w in ipairs(val) do
                rv[#rv+1] = w
            end
        else
            rv[#rv+1] = val
        end
    end
    return rv
end

function table.find(tbl,pred)
    pred = solvepredicate(pred)
    for i,v in ipairs(tbl) do
        if pred(v,i,tbl) then
            return v
        end
    end
    return nil
end

function table.kfind(tbl,pred)
    pred = solvepredicate(pred)
    for k,v in pairs(tbl) do
        if pred(v,k,tbl) then
            return v
        end
    end
    return nil
end

function table.findlast(tbl,pred)
    pred = solvepredicate(pred)
    for i=#tbl,1,-1 do
        if pred(tbl[i],i,tbl) then
            return tbl[i]
        end
    end
    return nil
end

function table.findindex(tbl,pred)
    pred = solvepredicate(pred)
    for i,v in ipairs(tbl) do
        if pred(v,i,tbl) then
            return i
        end
    end
    return 0
end

function table.findkey(tbl,pred)
    pred = solvepredicate(pred)
    for k,v in pairs(tbl) do
        if pred(v,k,tbl) then
            return k
        end
    end
    return nil
end

function table.findlastindex(tbl,pred)
    pred = solvepredicate(pred)
    for i=#tbl,1,-1 do
        if pred(tbl[i],i,tbl) then
            return i
        end
    end
    return 0
end

function table.indexof(tbl,val)
    for i,v in ipairs(tbl) do
        if v == val then
            return i
        end
    end
    return 0
end

function table.lastindexof(tbl,val)
    for i=#tbl,1,-1 do
        if tbl[i] == val then
            return i
        end
    end
    return 0
end

function table.keyof(tbl,val)
    for k,v in pairs(tbl) do
        if v == val then
            return k
        end
    end
    return nil
end

function table.includes(tbl,val)
    for _,v in ipairs(tbl) do
        if v == val then
            return true
        end
    end
    return false
end

function table.kincludes(tbl,val)
    for _,v in pairs(tbl) do
        if v == val then
            return true
        end
    end
    return false
end

function table.reduce(tbl,func,init)
    if #tbl == 0 and nil == init then return error("called reduce on empty table with no initial value") end
    local rv = init or tbl[1]
    for i,v in ipairs(tbl) do
        if not (init==nil and i==1) then
            rv = func(rv,v,i,tbl)
        end
    end
    return rv
end

function table.reduceright(tbl,func,init)
    if #tbl == 0 and nil == init then return error("called reduce on empty table with no initial value") end
    local rv = init or tbl[#tbl]
    for i=#tbl,1,-1 do
        if not (init==nil and i==#tbl) then
            rv = func(rv,tbl[i],i,tbl)
        end
    end
    return rv
end

function table.with(tbl,index,val)
    local rv = {}
    for i,v in ipairs(tbl) do
        rv[i] = i == index and val or v
    end
    return rv
end

function table.withkey(tbl,key,val)
    local rv = {}
    for k,v in pairs(tbl) do
        rv[k] = k == key and val or v
    end
    return rv
end

function table.forin(tbl,func)
    for i,v in ipairs(tbl) do
        func(v,i,tbl)
    end
end

function table.kforin(tbl,func)
    for k,v in pairs(tbl) do
        func(v,k,tbl)
    end
end

function table.keys(tbl)
    local rv = {}
    for k,_ in pairs(tbl) do
        rv[#rv+1] = k
    end
    return rv
end

function table.ikeys(tbl)
    local rv = {}
    for i,_ in ipairs(tbl) do
        rv[#rv+1] = i
    end
    return rv
end

function table.values(tbl)
    local rv = {}
    for _,v in pairs(tbl) do
        rv[#rv+1] = v
    end
    return rv
end

function table.ivalues(tbl)
    local rv = {}
    for _,v in ipairs(tbl) do
        rv[#rv+1] = v
    end
    return rv
end
'''
match_indent = true
times = 1